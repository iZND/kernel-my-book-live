/* ==========================================================	/* ==========================================================
 * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers	 * $File: //dwh/usb_iip/dev/software/otg_ipmate/linux/drivers
 * $Revision: #7 $						 * $Revision: #7 $
 * $Date: 2005/11/02 $						 * $Date: 2005/11/02 $
 * $Change: 553126 $						 * $Change: 553126 $
 *								 *
 * Synopsys HS OTG Linux Software Driver and documentation (h	 * Synopsys HS OTG Linux Software Driver and documentation (h
 * "Software") is an Unsupported proprietary work of Synopsys	 * "Software") is an Unsupported proprietary work of Synopsys
 * otherwise expressly agreed to in writing between Synopsys 	 * otherwise expressly agreed to in writing between Synopsys 
 *								 *
 * The Software IS NOT an item of Licensed Software or Licens	 * The Software IS NOT an item of Licensed Software or Licens
 * any End User Software License Agreement or Agreement for L	 * any End User Software License Agreement or Agreement for L
 * with Synopsys or any supplement thereto. You are permitted	 * with Synopsys or any supplement thereto. You are permitted
 * redistribute this Software in source and binary forms, wit	 * redistribute this Software in source and binary forms, wit
 * modification, provided that redistributions of source code	 * modification, provided that redistributions of source code
 * notice. You may not view, use, disclose, copy or distribut	 * notice. You may not view, use, disclose, copy or distribut
 * any information contained herein except pursuant to this l	 * any information contained herein except pursuant to this l
 * Synopsys. If you do not agree with this notice, including 	 * Synopsys. If you do not agree with this notice, including 
 * below, then you are not authorized to use the Software.	 * below, then you are not authorized to use the Software.
 *								 *
 * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON A	 * THIS SOFTWARE IS BEING DISTRIBUTED BY SYNOPSYS SOLELY ON A
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PA	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PA
 * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABL	 * ARE HEREBY DISCLAIMED. IN NO EVENT SHALL SYNOPSYS BE LIABL
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL	 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTER	 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT	 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARI	 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARI
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE PO	 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE PO
 * DAMAGE.							 * DAMAGE.
 * ==========================================================	 * ==========================================================

#ifndef CONFIG_DWC_DEVICE_ONLY					#ifndef CONFIG_DWC_DEVICE_ONLY

#include "dwc_otg_driver.h"					#include "dwc_otg_driver.h"
#include "dwc_otg_hcd.h"					#include "dwc_otg_hcd.h"
#include "dwc_otg_regs.h"					#include "dwc_otg_regs.h"

const int erratum_usb09_patched = 0;				const int erratum_usb09_patched = 0;
const int deferral_on = 1;					const int deferral_on = 1;
const int nak_deferral_delay = 8;			      |	int nak_deferral_delay = 20;
							      >	module_param(nak_deferral_delay, int, 0644);
const int nyet_deferral_delay = 1;				const int nyet_deferral_delay = 1;

/** @file							/** @file
 * This file contains the implementation of the HCD Interrupt	 * This file contains the implementation of the HCD Interrupt
 */								 */

/** This function handles interrupts for the HCD. */		/** This function handles interrupts for the HCD. */
int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t * _dwc_otg_hcd)	int32_t dwc_otg_hcd_handle_intr(dwc_otg_hcd_t * _dwc_otg_hcd)
{								{
	int retval = 0;							int retval = 0;
	dwc_otg_core_if_t * core_if = _dwc_otg_hcd->core_if;		dwc_otg_core_if_t * core_if = _dwc_otg_hcd->core_if;
	gintsts_data_t gintsts;						gintsts_data_t gintsts;

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
    dwc_otg_core_global_regs_t * global_regs = core_if->core_	    dwc_otg_core_global_regs_t * global_regs = core_if->core_

#endif	/*  */							#endif	/*  */

    /* Check if HOST Mode */					    /* Check if HOST Mode */
    if (dwc_otg_is_host_mode(core_if)) {			    if (dwc_otg_is_host_mode(core_if)) {
		gintsts.d32 = dwc_otg_read_core_intr(core_if)			gintsts.d32 = dwc_otg_read_core_intr(core_if)
		if (!gintsts.d32) {						if (!gintsts.d32) {
			return 0;							return 0;
		}								}
#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
	    /* Don't print debug message in the interrupt han		    /* Don't print debug message in the interrupt han
#ifndef DEBUG_SOF						#ifndef DEBUG_SOF
	    if (gintsts.d32 != DWC_SOF_INTR_MASK)			    if (gintsts.d32 != DWC_SOF_INTR_MASK)
#endif								#endif
		    DWC_DEBUGPL(DBG_HCD, "\n");					    DWC_DEBUGPL(DBG_HCD, "\n");
#endif	/*  */							#endif	/*  */

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
#ifndef DEBUG_SOF						#ifndef DEBUG_SOF
	    if (gintsts.d32 != DWC_SOF_INTR_MASK)			    if (gintsts.d32 != DWC_SOF_INTR_MASK)
#endif								#endif
		    DWC_DEBUGPL(DBG_HCD,"DWC OTG HCD Interrup			    DWC_DEBUGPL(DBG_HCD,"DWC OTG HCD Interrup
					gintsts.d32);							gintsts.d32);
#endif	/*  */							#endif	/*  */
	    if (gintsts.b.sofintr) {					    if (gintsts.b.sofintr) {
			retval |= dwc_otg_hcd_handle_sof_intr				retval |= dwc_otg_hcd_handle_sof_intr
		}								}
#ifdef CONFIG_OTG_PLB_DMA_TASKLET				#ifdef CONFIG_OTG_PLB_DMA_TASKLET
		if (!atomic_read(&release_later) && gintsts.b			if (!atomic_read(&release_later) && gintsts.b
#else								#else
		if (gintsts.b.rxstsqlvl) {					if (gintsts.b.rxstsqlvl) {
#endif								#endif
			retval |= dwc_otg_hcd_handle_rx_statu				retval |= dwc_otg_hcd_handle_rx_statu
		}								}
#ifdef CONFIG_OTG_PLB_DMA_TASKLET				#ifdef CONFIG_OTG_PLB_DMA_TASKLET
		if (!atomic_read(&release_later) && gintsts.b			if (!atomic_read(&release_later) && gintsts.b
#else								#else
		if (gintsts.b.nptxfempty) {					if (gintsts.b.nptxfempty) {
#endif								#endif
			retval |= dwc_otg_hcd_handle_np_tx_fi				retval |= dwc_otg_hcd_handle_np_tx_fi
		}								}
		if (gintsts.b.i2cintr) {					if (gintsts.b.i2cintr) {
			/** @todo Implement i2cintr handler. 				/** @todo Implement i2cintr handler. 
		}								}
		if (gintsts.b.portintr) {					if (gintsts.b.portintr) {
			retval |= dwc_otg_hcd_handle_port_int				retval |= dwc_otg_hcd_handle_port_int
		}								}
		if (gintsts.b.hcintr) {						if (gintsts.b.hcintr) {
			retval |= dwc_otg_hcd_handle_hc_intr(				retval |= dwc_otg_hcd_handle_hc_intr(
		}								}
		if (gintsts.b.ptxfempty) {					if (gintsts.b.ptxfempty) {
			retval |= dwc_otg_hcd_handle_perio_tx				retval |= dwc_otg_hcd_handle_perio_tx
		}								}

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
#ifndef DEBUG_SOF						#ifndef DEBUG_SOF
	    if (gintsts.d32 != DWC_SOF_INTR_MASK)			    if (gintsts.d32 != DWC_SOF_INTR_MASK)
#endif								#endif
		{								{
			DWC_DEBUGPL(DBG_HCD,						DWC_DEBUGPL(DBG_HCD,
				     "DWC OTG HCD Finished Se					     "DWC OTG HCD Finished Se
			DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD gi				DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD gi
				     dwc_read_reg32(&global_r					     dwc_read_reg32(&global_r
			DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD gi				DWC_DEBUGPL(DBG_HCDV, "DWC OTG HCD gi
				     dwc_read_reg32(&global_r					     dwc_read_reg32(&global_r
		}								}
#endif	/*  */							#endif	/*  */

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
#ifndef DEBUG_SOF						#ifndef DEBUG_SOF
	    if (gintsts.d32 != DWC_SOF_INTR_MASK)			    if (gintsts.d32 != DWC_SOF_INTR_MASK)
#endif								#endif
		    DWC_DEBUGPL(DBG_HCD, "\n");					    DWC_DEBUGPL(DBG_HCD, "\n");
#endif	/*  */							#endif	/*  */
	}								}
	return retval;							return retval;
}								}


#ifdef DWC_TRACK_MISSED_SOFS					#ifdef DWC_TRACK_MISSED_SOFS
#warning Compiling code to track missed SOFs			#warning Compiling code to track missed SOFs
#define FRAME_NUM_ARRAY_SIZE 1000				#define FRAME_NUM_ARRAY_SIZE 1000
/**								/**
 * This function is for debug only.				 * This function is for debug only.
 */								 */
static inline void track_missed_sofs(uint16_t _curr_frame_num	static inline void track_missed_sofs(uint16_t _curr_frame_num
{								{
	static uint16_t frame_num_array[FRAME_NUM_ARRAY_SIZE]		static uint16_t frame_num_array[FRAME_NUM_ARRAY_SIZE]
	static uint16_t last_frame_num_array[FRAME_NUM_ARRAY_		static uint16_t last_frame_num_array[FRAME_NUM_ARRAY_
	static int frame_num_idx = 0;					static int frame_num_idx = 0;
	static uint16_t last_frame_num = DWC_HFNUM_MAX_FRNUM;		static uint16_t last_frame_num = DWC_HFNUM_MAX_FRNUM;
	static int dumped_frame_num_array = 0;				static int dumped_frame_num_array = 0;
	if (frame_num_idx < FRAME_NUM_ARRAY_SIZE) {			if (frame_num_idx < FRAME_NUM_ARRAY_SIZE) {
		if ((((last_frame_num + 1) & DWC_HFNUM_MAX_FR			if ((((last_frame_num + 1) & DWC_HFNUM_MAX_FR
		      _curr_frame_number)) {					      _curr_frame_number)) {
			frame_num_array[frame_num_idx] = _cur				frame_num_array[frame_num_idx] = _cur
			last_frame_num_array[frame_num_idx++]				last_frame_num_array[frame_num_idx++]
		}								}
	} else if (!dumped_frame_num_array) {				} else if (!dumped_frame_num_array) {
		int i;								int i;
		printk(KERN_EMERG USB_DWC "Frame     Last Fra			printk(KERN_EMERG USB_DWC "Frame     Last Fra
		printk(KERN_EMERG USB_DWC "-----     --------			printk(KERN_EMERG USB_DWC "-----     --------
		for (i = 0; i < FRAME_NUM_ARRAY_SIZE; i++) {			for (i = 0; i < FRAME_NUM_ARRAY_SIZE; i++) {
			printk(KERN_EMERG USB_DWC "0x%04x    				printk(KERN_EMERG USB_DWC "0x%04x    
				frame_num_array[i], last_fram					frame_num_array[i], last_fram
		}								}
		dumped_frame_num_array = 1;					dumped_frame_num_array = 1;
	}								}
	last_frame_num = _curr_frame_number;				last_frame_num = _curr_frame_number;
}								}
#endif	/*  */							#endif	/*  */

/**								/**
 * Handles the start-of-frame interrupt in host mode. Non-per	 * Handles the start-of-frame interrupt in host mode. Non-per
 * transactions may be queued to the DWC_otg controller for t	 * transactions may be queued to the DWC_otg controller for t
 * (micro)frame. Periodic transactions may be queued to the c	 * (micro)frame. Periodic transactions may be queued to the c
 * next (micro)frame.						 * next (micro)frame.
 */								 */
int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t * _hcd)	int32_t dwc_otg_hcd_handle_sof_intr(dwc_otg_hcd_t * _hcd)
{								{
	hfnum_data_t hfnum;						hfnum_data_t hfnum;
	struct list_head *qh_entry;					struct list_head *qh_entry;
	dwc_otg_qh_t * qh;						dwc_otg_qh_t * qh;
	dwc_otg_transaction_type_e tr_type;				dwc_otg_transaction_type_e tr_type;
	gintsts_data_t gintsts = {.d32 = 0};				gintsts_data_t gintsts = {.d32 = 0};
	hfnum.d32 = dwc_read_reg32(&_hcd->core_if->host_if->h		hfnum.d32 = dwc_read_reg32(&_hcd->core_if->host_if->h

#ifdef DEBUG_SOF						#ifdef DEBUG_SOF
    DWC_DEBUGPL(DBG_HCD, "--Start of Frame Interrupt--\n");	    DWC_DEBUGPL(DBG_HCD, "--Start of Frame Interrupt--\n");
#endif	/*  */							#endif	/*  */
    _hcd->frame_number = hfnum.b.frnum;				    _hcd->frame_number = hfnum.b.frnum;
#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
    _hcd->frrem_accum += hfnum.b.frrem;				    _hcd->frrem_accum += hfnum.b.frrem;
	_hcd->frrem_samples++;						_hcd->frrem_samples++;
#endif	/*  */							#endif	/*  */

#ifdef DWC_TRACK_MISSED_SOFS					#ifdef DWC_TRACK_MISSED_SOFS
    track_missed_sofs(_hcd->frame_number);			    track_missed_sofs(_hcd->frame_number);
#endif	/*  */							#endif	/*  */

    /* Determine whether any periodic QHs should be executed.	    /* Determine whether any periodic QHs should be executed.
    qh_entry = _hcd->periodic_sched_inactive.next;		    qh_entry = _hcd->periodic_sched_inactive.next;
	while (qh_entry != &_hcd->periodic_sched_inactive) {		while (qh_entry != &_hcd->periodic_sched_inactive) {
		qh = list_entry(qh_entry, dwc_otg_qh_t, qh_li			qh = list_entry(qh_entry, dwc_otg_qh_t, qh_li
		qh_entry = qh_entry->next;					qh_entry = qh_entry->next;
		if (dwc_frame_num_le(qh->sched_frame, _hcd->f			if (dwc_frame_num_le(qh->sched_frame, _hcd->f
		    /*								    /*
		     * Move QH to the ready list to be execut			     * Move QH to the ready list to be execut
		     * (micro)frame.						     * (micro)frame.
		     */								     */
		    list_move(&qh->qh_list_entry,&_hcd->perio			    list_move(&qh->qh_list_entry,&_hcd->perio
		}								}
	}								}
	tr_type = dwc_otg_hcd_select_transactions(_hcd);		tr_type = dwc_otg_hcd_select_transactions(_hcd);
	if (tr_type != DWC_OTG_TRANSACTION_NONE) {			if (tr_type != DWC_OTG_TRANSACTION_NONE) {
		dwc_otg_hcd_queue_transactions(_hcd, tr_type)			dwc_otg_hcd_queue_transactions(_hcd, tr_type)
		//schedule_work(&_hcd->hcd_queue_work);				//schedule_work(&_hcd->hcd_queue_work);
	}								}

    /* Clear interrupt */					    /* Clear interrupt */
    gintsts.b.sofintr = 1;					    gintsts.b.sofintr = 1;
	dwc_write_reg32(&_hcd->core_if->core_global_regs->gin		dwc_write_reg32(&_hcd->core_if->core_global_regs->gin
	return 1;							return 1;
}								}

/** Handles the Rx Status Queue Level Interrupt, which indica	/** Handles the Rx Status Queue Level Interrupt, which indica
 * least one packet in the Rx FIFO.  The packets are moved fr	 * least one packet in the Rx FIFO.  The packets are moved fr
 * memory if the DWC_otg controller is operating in Slave mod	 * memory if the DWC_otg controller is operating in Slave mod
int32_t dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_hcd	int32_t dwc_otg_hcd_handle_rx_status_q_level_intr(dwc_otg_hcd
{								{
	host_grxsts_data_t grxsts;					host_grxsts_data_t grxsts;
	dwc_hc_t * hc = NULL;						dwc_hc_t * hc = NULL;
	DWC_DEBUGPL(DBG_HCD, "--RxStsQ Level Interrupt--\n");		DWC_DEBUGPL(DBG_HCD, "--RxStsQ Level Interrupt--\n");
	grxsts.d32 = dwc_read_reg32(&_dwc_otg_hcd->core_if->c		grxsts.d32 = dwc_read_reg32(&_dwc_otg_hcd->core_if->c
	hc = _dwc_otg_hcd->hc_ptr_array[grxsts.b.chnum];		hc = _dwc_otg_hcd->hc_ptr_array[grxsts.b.chnum];

    /* Packet Status */						    /* Packet Status */
    DWC_DEBUGPL(DBG_HCDV, "    Ch num = %d\n", grxsts.b.chnum	    DWC_DEBUGPL(DBG_HCDV, "    Ch num = %d\n", grxsts.b.chnum
	DWC_DEBUGPL(DBG_HCDV, "    Count = %d\n", grxsts.b.bc		DWC_DEBUGPL(DBG_HCDV, "    Count = %d\n", grxsts.b.bc
	DWC_DEBUGPL(DBG_HCDV, "    DPID = %d, hc.dpid = %d\n"		DWC_DEBUGPL(DBG_HCDV, "    DPID = %d, hc.dpid = %d\n"
		     hc->data_pid_start);					     hc->data_pid_start);
	DWC_DEBUGPL(DBG_HCDV, "    PStatus = %d\n", grxsts.b.		DWC_DEBUGPL(DBG_HCDV, "    PStatus = %d\n", grxsts.b.
	switch (grxsts.b.pktsts) {					switch (grxsts.b.pktsts) {
	case DWC_GRXSTS_PKTSTS_IN:					case DWC_GRXSTS_PKTSTS_IN:
	    /* Read the data into the host buffer. */			    /* Read the data into the host buffer. */
	    if (grxsts.b.bcnt > 0) {					    if (grxsts.b.bcnt > 0) {
			dwc_otg_read_packet(_dwc_otg_hcd->cor				dwc_otg_read_packet(_dwc_otg_hcd->cor
					     hc->xfer_buff, g						     hc->xfer_buff, g

		    /* Update the HC fields for the next pack			    /* Update the HC fields for the next pack
		    hc->xfer_count += grxsts.b.bcnt;				    hc->xfer_count += grxsts.b.bcnt;
			hc->xfer_buff += grxsts.b.bcnt;					hc->xfer_buff += grxsts.b.bcnt;
		}								}
	case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:				case DWC_GRXSTS_PKTSTS_IN_XFER_COMP:
	case DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:				case DWC_GRXSTS_PKTSTS_DATA_TOGGLE_ERR:
	case DWC_GRXSTS_PKTSTS_CH_HALTED:				case DWC_GRXSTS_PKTSTS_CH_HALTED:
		    /* Handled in interrupt, just ignore data			    /* Handled in interrupt, just ignore data
		    break;							    break;
	default:							default:
		DWC_ERROR("RX_STS_Q Interrupt: Unknown status			DWC_ERROR("RX_STS_Q Interrupt: Unknown status
			   grxsts.b.pktsts);						   grxsts.b.pktsts);
		break;								break;
	}								}
	return 1;							return 1;
}								}


/** This interrupt occurs when the non-periodic Tx FIFO is ha	/** This interrupt occurs when the non-periodic Tx FIFO is ha
 * data packets may be written to the FIFO for OUT transfers.	 * data packets may be written to the FIFO for OUT transfers.
 * may be written to the non-periodic request queue for IN tr	 * may be written to the non-periodic request queue for IN tr
 * interrupt is enabled only in Slave mode. */			 * interrupt is enabled only in Slave mode. */
int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr(dwc_otg_hcd_	int32_t dwc_otg_hcd_handle_np_tx_fifo_empty_intr(dwc_otg_hcd_
						     _dwc_otg							     _dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Non-Periodic TxFIFO Empty Int		DWC_DEBUGPL(DBG_HCD, "--Non-Periodic TxFIFO Empty Int
	dwc_otg_hcd_queue_transactions(_dwc_otg_hcd,			dwc_otg_hcd_queue_transactions(_dwc_otg_hcd,
					DWC_OTG_TRANSACTION_N						DWC_OTG_TRANSACTION_N
	//schedule_work(&_dwc_otg_hcd->hcd_queue_work);			//schedule_work(&_dwc_otg_hcd->hcd_queue_work);
	return 1;							return 1;
}								}


/** This interrupt occurs when the periodic Tx FIFO is half-e	/** This interrupt occurs when the periodic Tx FIFO is half-e
 * packets may be written to the FIFO for OUT transfers. More	 * packets may be written to the FIFO for OUT transfers. More
 * written to the periodic request queue for IN transfers. Th	 * written to the periodic request queue for IN transfers. Th
 * enabled only in Slave mode. */				 * enabled only in Slave mode. */
int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr(dwc_otg_h	int32_t dwc_otg_hcd_handle_perio_tx_fifo_empty_intr(dwc_otg_h
							_dwc_								_dwc_
{								{
	DWC_DEBUGPL(DBG_HCD, "--Periodic TxFIFO Empty Interru		DWC_DEBUGPL(DBG_HCD, "--Periodic TxFIFO Empty Interru
	dwc_otg_hcd_queue_transactions(_dwc_otg_hcd,			dwc_otg_hcd_queue_transactions(_dwc_otg_hcd,
					DWC_OTG_TRANSACTION_P						DWC_OTG_TRANSACTION_P
	//schedule_work(&_dwc_otg_hcd->hcd_queue_work);			//schedule_work(&_dwc_otg_hcd->hcd_queue_work);
	return 1;							return 1;
}								}


/** There are multiple conditions that can cause a port inter	/** There are multiple conditions that can cause a port inter
 * determines which interrupt conditions have occurred and ha	 * determines which interrupt conditions have occurred and ha
 * appropriately. */						 * appropriately. */
int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * _dwc_otg	int32_t dwc_otg_hcd_handle_port_intr(dwc_otg_hcd_t * _dwc_otg
{								{
	int retval = 0;							int retval = 0;
	hprt0_data_t hprt0;						hprt0_data_t hprt0;
	hprt0_data_t hprt0_modify;					hprt0_data_t hprt0_modify;
	hprt0.d32 = dwc_read_reg32(_dwc_otg_hcd->core_if->hos		hprt0.d32 = dwc_read_reg32(_dwc_otg_hcd->core_if->hos
	hprt0_modify.d32 = dwc_read_reg32(_dwc_otg_hcd->core_		hprt0_modify.d32 = dwc_read_reg32(_dwc_otg_hcd->core_

    /* Clear appropriate bits in HPRT0 to clear the interrupt	    /* Clear appropriate bits in HPRT0 to clear the interrupt
     * GINTSTS */						     * GINTSTS */
    hprt0_modify.b.prtena = 0;					    hprt0_modify.b.prtena = 0;
	hprt0_modify.b.prtconndet = 0;					hprt0_modify.b.prtconndet = 0;
	hprt0_modify.b.prtenchng = 0;					hprt0_modify.b.prtenchng = 0;
	hprt0_modify.b.prtovrcurrchng = 0;				hprt0_modify.b.prtovrcurrchng = 0;

    /* Port Connect Detected					    /* Port Connect Detected
     * Set flag and clear if detected */			     * Set flag and clear if detected */
    if (hprt0.b.prtconndet) {					    if (hprt0.b.prtconndet) {
		DWC_DEBUGPL(DBG_HCD, "--Port Interrupt HPRT0=			DWC_DEBUGPL(DBG_HCD, "--Port Interrupt HPRT0=
			     "Port Connect Detected--\n", hpr				     "Port Connect Detected--\n", hpr
		_dwc_otg_hcd->flags.b.port_connect_status_cha			_dwc_otg_hcd->flags.b.port_connect_status_cha
		_dwc_otg_hcd->flags.b.port_connect_status = 1			_dwc_otg_hcd->flags.b.port_connect_status = 1
		hprt0_modify.b.prtconndet = 1;					hprt0_modify.b.prtconndet = 1;

	    /* B-Device has connected, Delete the connection 		    /* B-Device has connected, Delete the connection 
	    del_timer(&_dwc_otg_hcd->conn_timer);			    del_timer(&_dwc_otg_hcd->conn_timer);

	    /* The Hub driver asserts a reset when it sees po		    /* The Hub driver asserts a reset when it sees po
	     * status change flag					     * status change flag
		 */								 */
	    retval |= 1;						    retval |= 1;
	}								}

    /* Port Enable Changed					    /* Port Enable Changed
     * Clear if detected - Set internal flag if disabled */	     * Clear if detected - Set internal flag if disabled */
    if (hprt0.b.prtenchng) {					    if (hprt0.b.prtenchng) {
		DWC_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT			DWC_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT
			     "Port Enable Changed--\n", hprt0				     "Port Enable Changed--\n", hprt0
		hprt0_modify.b.prtenchng = 1;					hprt0_modify.b.prtenchng = 1;
		if (hprt0.b.prtena == 1) {					if (hprt0.b.prtena == 1) {
			int do_reset = 0;						int do_reset = 0;
			dwc_otg_core_params_t * params =				dwc_otg_core_params_t * params =
			    _dwc_otg_hcd->core_if->core_param				    _dwc_otg_hcd->core_if->core_param
			dwc_otg_core_global_regs_t * global_r				dwc_otg_core_global_regs_t * global_r
			    _dwc_otg_hcd->core_if->core_globa				    _dwc_otg_hcd->core_if->core_globa
			dwc_otg_host_if_t * host_if =					dwc_otg_host_if_t * host_if =
			    _dwc_otg_hcd->core_if->host_if;				    _dwc_otg_hcd->core_if->host_if;

		    /* Check if we need to adjust the PHY clo			    /* Check if we need to adjust the PHY clo
		     * low power and adjust it */				     * low power and adjust it */
		    if (params->host_support_fs_ls_low_power)			    if (params->host_support_fs_ls_low_power)
				gusbcfg_data_t usbcfg;						gusbcfg_data_t usbcfg;
				usbcfg.d32 = dwc_read_reg32(&					usbcfg.d32 = dwc_read_reg32(&
				if ((hprt0.b.prtspd == DWC_HP					if ((hprt0.b.prtspd == DWC_HP
					(hprt0.b.prtspd == DW						(hprt0.b.prtspd == DW
				    /*								    /*
				     * Low power						     * Low power
				     */								     */
				    hcfg_data_t hcfg;						    hcfg_data_t hcfg;
					if (usbcfg.b.phylpwrc						if (usbcfg.b.phylpwrc
					    /* Set PHY low po						    /* Set PHY low po
					    usbcfg.b.phylpwrc						    usbcfg.b.phylpwrc
						dwc_write_reg							dwc_write_reg
						do_reset = 1;							do_reset = 1;
					}								}
					hcfg.d32 = dwc_read_r						hcfg.d32 = dwc_read_r
					if ((hprt0.b.prtspd =						if ((hprt0.b.prtspd =
						(params->host							(params->host
						DWC_HOST_LS_L							DWC_HOST_LS_L
					    /* 6 MHZ */							    /* 6 MHZ */
					    DWC_DEBUGPL(DBG_C						    DWC_DEBUGPL(DBG_C
						if (hcfg.b.fs							if (hcfg.b.fs
							hcfg.								hcfg.
							dwc_w								dwc_w
							do_re								do_re
						}								}
					} else {							} else {
					    /* 48 MHZ */						    /* 48 MHZ */
					    DWC_DEBUGPL(DBG_C						    DWC_DEBUGPL(DBG_C
						if (hcfg.b.fs							if (hcfg.b.fs
							hcfg.								hcfg.
							dwc_w								dwc_w
							do_re								do_re
						}								}
					}								}
				} else {							} else {
				    /*								    /*
				     * Not low power						     * Not low power
				     */								     */
				    if (usbcfg.b.phylpwrclkse					    if (usbcfg.b.phylpwrclkse
						usbcfg.b.phyl							usbcfg.b.phyl
						dwc_write_reg							dwc_write_reg
						do_reset = 1;							do_reset = 1;
					}								}
				}								}
				if (do_reset) {							if (do_reset) {
					tasklet_schedule(_dwc						tasklet_schedule(_dwc
				}								}
			}								}
			if (!do_reset) {						if (!do_reset) {
			    /* Port has been enabled set the 				    /* Port has been enabled set the 
			    _dwc_otg_hcd->flags.b.port_reset_				    _dwc_otg_hcd->flags.b.port_reset_
			}								}
		} else {							} else {
			_dwc_otg_hcd->flags.b.port_enable_cha				_dwc_otg_hcd->flags.b.port_enable_cha
		}								}
		retval |= 1;							retval |= 1;
	}								}

	/** Overcurrent Change Interrupt */				/** Overcurrent Change Interrupt */
    if (hprt0.b.prtovrcurrchng) {				    if (hprt0.b.prtovrcurrchng) {
		DWC_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT			DWC_DEBUGPL(DBG_HCD, "  --Port Interrupt HPRT
			     "Port Overcurrent Changed--\n", 				     "Port Overcurrent Changed--\n", 
		_dwc_otg_hcd->flags.b.port_over_current_chang			_dwc_otg_hcd->flags.b.port_over_current_chang
		hprt0_modify.b.prtovrcurrchng = 1;				hprt0_modify.b.prtovrcurrchng = 1;
		retval |= 1;							retval |= 1;
	}								}

    /* Clear Port Interrupts */					    /* Clear Port Interrupts */
    dwc_write_reg32(_dwc_otg_hcd->core_if->host_if->hprt0,hpr	    dwc_write_reg32(_dwc_otg_hcd->core_if->host_if->hprt0,hpr
	return retval;							return retval;
}								}

/** This interrupt indicates that one or more host channels h	/** This interrupt indicates that one or more host channels h
 * interrupt. There are multiple conditions that can cause ea	 * interrupt. There are multiple conditions that can cause ea
 * interrupt. This function determines which conditions have 	 * interrupt. This function determines which conditions have 
 * host channel interrupt and handles them appropriately. */	 * host channel interrupt and handles them appropriately. */
int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t * _dwc_otg_h	int32_t dwc_otg_hcd_handle_hc_intr(dwc_otg_hcd_t * _dwc_otg_h
{								{
	int i;								int i;
	int retval = 0;							int retval = 0;
	haint_data_t haint;						haint_data_t haint;

    /* Clear appropriate bits in HCINTn to clear the interrup	    /* Clear appropriate bits in HCINTn to clear the interrup
     * GINTSTS */						     * GINTSTS */
    haint.d32 = dwc_otg_read_host_all_channels_intr(_dwc_otg_	    haint.d32 = dwc_otg_read_host_all_channels_intr(_dwc_otg_
	for (i = 0; i < _dwc_otg_hcd->core_if->core_params->h		for (i = 0; i < _dwc_otg_hcd->core_if->core_params->h
		if (haint.b2.chint & (1 << i)) {				if (haint.b2.chint & (1 << i)) {
			retval |= dwc_otg_hcd_handle_hc_n_int				retval |= dwc_otg_hcd_handle_hc_n_int
		}								}
	}								}
	return retval;							return retval;
}								}

/* Macro used to clear one channel interrupt */			/* Macro used to clear one channel interrupt */
#define clear_hc_int(_hc_regs_,_intr_) \			#define clear_hc_int(_hc_regs_,_intr_) \
    do { \							    do { \
		hcint_data_t hcint_clear = { .d32 = 0}; \			hcint_data_t hcint_clear = { .d32 = 0}; \
		hcint_clear.b._intr_ = 1; \					hcint_clear.b._intr_ = 1; \
		dwc_write_reg32(&((_hc_regs_)->hcint), hcint_			dwc_write_reg32(&((_hc_regs_)->hcint), hcint_
	} while (0)							} while (0)

/*								/*
 * Macro used to disable one channel interrupt. Channel inter	 * Macro used to disable one channel interrupt. Channel inter
 * disabled when the channel is halted or released by the int	 * disabled when the channel is halted or released by the int
 * There is no need to handle further interrupts of that type	 * There is no need to handle further interrupts of that type
 * channel is re-assigned. In fact, subsequent handling may c	 * channel is re-assigned. In fact, subsequent handling may c
 * because the channel structures are cleaned up when the cha	 * because the channel structures are cleaned up when the cha
 */								 */
#define disable_hc_int(_hc_regs_,_intr_) \			#define disable_hc_int(_hc_regs_,_intr_) \
    do { \							    do { \
		hcintmsk_data_t hcintmsk = {.d32 = 0}; \			hcintmsk_data_t hcintmsk = {.d32 = 0}; \
		hcintmsk.b._intr_ = 1; \					hcintmsk.b._intr_ = 1; \
		dwc_modify_reg32(&((_hc_regs_)->hcintmsk), hc			dwc_modify_reg32(&((_hc_regs_)->hcintmsk), hc
	} while (0)							} while (0)

/**								/**
 * Gets the actual length of a transfer after the transfer ha	 * Gets the actual length of a transfer after the transfer ha
 * holds the reason for the halt.				 * holds the reason for the halt.
 *								 *
 * For IN transfers where _halt_status is DWC_OTG_HC_XFER_COM	 * For IN transfers where _halt_status is DWC_OTG_HC_XFER_COM
 * *_short_read is set to 1 upon return if less than the requ	 * *_short_read is set to 1 upon return if less than the requ
 * number of bytes were transferred. Otherwise, *_short_read 	 * number of bytes were transferred. Otherwise, *_short_read 
 * return. _short_read may also be NULL on entry, in which ca	 * return. _short_read may also be NULL on entry, in which ca
 * unchanged.							 * unchanged.
 */								 */
static uint32_t get_actual_xfer_length(dwc_hc_t * _hc,		static uint32_t get_actual_xfer_length(dwc_hc_t * _hc,
       dwc_otg_hc_regs_t * _hc_regs, dwc_otg_qtd_t * _qtd,	       dwc_otg_hc_regs_t * _hc_regs, dwc_otg_qtd_t * _qtd,
       dwc_otg_halt_status_e _halt_status, int *_short_read)	       dwc_otg_halt_status_e _halt_status, int *_short_read)
{								{
	hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
	uint32_t length;						uint32_t length;
	if (_short_read != NULL) {					if (_short_read != NULL) {
		*_short_read = 0;						*_short_read = 0;
	}								}
	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
	if (_halt_status == DWC_OTG_HC_XFER_COMPLETE) {			if (_halt_status == DWC_OTG_HC_XFER_COMPLETE) {
		if (_hc->ep_is_in) {						if (_hc->ep_is_in) {
			length = _hc->xfer_len - hctsiz.b.xfe				length = _hc->xfer_len - hctsiz.b.xfe
			if (_short_read != NULL) {					if (_short_read != NULL) {
				*_short_read = (hctsiz.b.xfer					*_short_read = (hctsiz.b.xfer
			}								}
		} else if (_hc->qh->do_split) {					} else if (_hc->qh->do_split) {
			length = _qtd->ssplit_out_xfer_count;				length = _qtd->ssplit_out_xfer_count;
		} else {							} else {
			length = _hc->xfer_len;						length = _hc->xfer_len;
		}								}
	} else {							} else {
	    /*								    /*
	     * Must use the hctsiz.pktcnt field to determine 		     * Must use the hctsiz.pktcnt field to determine 
	     * has been transferred. This field reflects the 		     * has been transferred. This field reflects the 
	     * packets that have been transferred via the USB		     * packets that have been transferred via the USB
	     * always an integral number of packets if the tr		     * always an integral number of packets if the tr
	     * halted before its normal completion. (Can't us		     * halted before its normal completion. (Can't us
	     * hctsiz.xfersize field because that reflects th		     * hctsiz.xfersize field because that reflects th
	     * bytes transferred via the AHB, not the USB).		     * bytes transferred via the AHB, not the USB).
	     */								     */
	    length = (_hc->start_pkt_count - hctsiz.b.pktcnt)		    length = (_hc->start_pkt_count - hctsiz.b.pktcnt)
	}								}
	return length;							return length;
}								}

/**								/**
 * Updates the state of the URB after a Transfer Complete int	 * Updates the state of the URB after a Transfer Complete int
 * host channel. Updates the actual_length field of the URB b	 * host channel. Updates the actual_length field of the URB b
 * number of bytes transferred via the host channel. Sets the	 * number of bytes transferred via the host channel. Sets the
 * if the data transfer is finished.				 * if the data transfer is finished.
 *								 *
 * @return 1 if the data transfer specified by the URB is com	 * @return 1 if the data transfer specified by the URB is com
 * 0 otherwise.							 * 0 otherwise.
 */								 */
static int update_urb_state_xfer_comp(dwc_hc_t * _hc,		static int update_urb_state_xfer_comp(dwc_hc_t * _hc,
				      dwc_otg_hc_regs_t * _hc					      dwc_otg_hc_regs_t * _hc
				      dwc_otg_qtd_t * _qtd, i					      dwc_otg_qtd_t * _qtd, i
{								{
	int xfer_done = 0;						int xfer_done = 0;
	int short_read = 0;						int short_read = 0;
	_urb->actual_length += get_actual_xfer_length(_hc, _h		_urb->actual_length += get_actual_xfer_length(_hc, _h
				   DWC_OTG_HC_XFER_COMPLETE, 					   DWC_OTG_HC_XFER_COMPLETE, 
	if (short_read || (_urb->actual_length == _urb->trans		if (short_read || (_urb->actual_length == _urb->trans
		xfer_done = 1;							xfer_done = 1;
		if (_urb->actual_length == _urb->transfer_buf |			if (short_read && (_urb->transfer_flags & URB
			*status = 0;			      <
		} else if (short_read && (_urb->transfer_flag <
			*status = -EREMOTEIO;						*status = -EREMOTEIO;
		} else {							} else {
			*status = 0;							*status = 0;
		}								}
	}								}

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
	{								{
		hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
		hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz
		DWC_DEBUGPL(DBG_HCDV, "DWC_otg: %s: %s, chann			DWC_DEBUGPL(DBG_HCDV, "DWC_otg: %s: %s, chann
			     __func__, (_hc->ep_is_in ? "IN" 				     __func__, (_hc->ep_is_in ? "IN" 
		DWC_DEBUGPL(DBG_HCDV, "  hc->xfer_len %d\n", 			DWC_DEBUGPL(DBG_HCDV, "  hc->xfer_len %d\n", 
		DWC_DEBUGPL(DBG_HCDV, "  hctsiz.xfersize %d\n			DWC_DEBUGPL(DBG_HCDV, "  hctsiz.xfersize %d\n
		DWC_DEBUGPL(DBG_HCDV, "  urb->transfer_buffer			DWC_DEBUGPL(DBG_HCDV, "  urb->transfer_buffer
			     _urb->transfer_buffer_length);				     _urb->transfer_buffer_length);
		DWC_DEBUGPL(DBG_HCDV, "  urb->actual_length %			DWC_DEBUGPL(DBG_HCDV, "  urb->actual_length %
			     _urb->actual_length);					     _urb->actual_length);
		DWC_DEBUGPL(DBG_HCDV, "  short_read %d, xfer_			DWC_DEBUGPL(DBG_HCDV, "  short_read %d, xfer_
			     short_read, xfer_done);					     short_read, xfer_done);
	}								}
#endif	/*  */							#endif	/*  */
    return xfer_done;						    return xfer_done;
}								}

/*								/*
 * Save the starting data toggle for the next transfer. The d	 * Save the starting data toggle for the next transfer. The d
 * saved in the QH for non-control transfers and it's saved i	 * saved in the QH for non-control transfers and it's saved i
 * control transfers.						 * control transfers.
 */								 */
static void save_data_toggle(dwc_hc_t * _hc,			static void save_data_toggle(dwc_hc_t * _hc,
	dwc_otg_hc_regs_t * _hc_regs, dwc_otg_qtd_t * _qtd)		dwc_otg_hc_regs_t * _hc_regs, dwc_otg_qtd_t * _qtd)
{								{
	hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
	if (_hc->ep_type != DWC_OTG_EP_TYPE_CONTROL) {			if (_hc->ep_type != DWC_OTG_EP_TYPE_CONTROL) {
		dwc_otg_qh_t * qh = _hc->qh;					dwc_otg_qh_t * qh = _hc->qh;
		if (hctsiz.b.pid == DWC_HCTSIZ_DATA0) {				if (hctsiz.b.pid == DWC_HCTSIZ_DATA0) {
			qh->data_toggle = DWC_OTG_HC_PID_DATA				qh->data_toggle = DWC_OTG_HC_PID_DATA
		} else {							} else {
			qh->data_toggle = DWC_OTG_HC_PID_DATA				qh->data_toggle = DWC_OTG_HC_PID_DATA
		}								}
	} else {							} else {
		if (hctsiz.b.pid == DWC_HCTSIZ_DATA0) {				if (hctsiz.b.pid == DWC_HCTSIZ_DATA0) {
			_qtd->data_toggle = DWC_OTG_HC_PID_DA				_qtd->data_toggle = DWC_OTG_HC_PID_DA
		} else {							} else {
			_qtd->data_toggle = DWC_OTG_HC_PID_DA				_qtd->data_toggle = DWC_OTG_HC_PID_DA
		}								}
	}								}
}								}

/**								/**
 * Frees the first QTD in the QH's list if free_qtd is 1. For	 * Frees the first QTD in the QH's list if free_qtd is 1. For
 * QHs, removes the QH from the active non-periodic schedule.	 * QHs, removes the QH from the active non-periodic schedule.
 * still linked to the QH, the QH is added to the end of the 	 * still linked to the QH, the QH is added to the end of the 
 * non-periodic schedule. For periodic QHs, removes the QH fr	 * non-periodic schedule. For periodic QHs, removes the QH fr
 * schedule if no more QTDs are linked to the QH.		 * schedule if no more QTDs are linked to the QH.
 */								 */
static void deactivate_qh(dwc_otg_hcd_t * _hcd,			static void deactivate_qh(dwc_otg_hcd_t * _hcd,
			  dwc_otg_qh_t * _qh,  int free_qtd)				  dwc_otg_qh_t * _qh,  int free_qtd)
{								{
	int continue_split = 0;						int continue_split = 0;
	dwc_otg_qtd_t * qtd;						dwc_otg_qtd_t * qtd;
	DWC_DEBUGPL(DBG_HCDV, "  %s(%p,%p,%d)\n", __func__, _		DWC_DEBUGPL(DBG_HCDV, "  %s(%p,%p,%d)\n", __func__, _
		      free_qtd);						      free_qtd);
	qtd = list_entry(_qh->qtd_list.next, dwc_otg_qtd_t, q		qtd = list_entry(_qh->qtd_list.next, dwc_otg_qtd_t, q
	if (qtd->complete_split) {					if (qtd->complete_split) {
		continue_split = 1;						continue_split = 1;
	} else if ((qtd->isoc_split_pos == DWC_HCSPLIT_XACTPO		} else if ((qtd->isoc_split_pos == DWC_HCSPLIT_XACTPO
		(qtd->isoc_split_pos == DWC_HCSPLIT_XACTPOS_E			(qtd->isoc_split_pos == DWC_HCSPLIT_XACTPOS_E
		continue_split = 1;						continue_split = 1;
	}								}

	if (free_qtd) {							if (free_qtd) {
		/*								/*
		 * Note that this was previously a call to			 * Note that this was previously a call to
		 * dwc_otg_hcd_qtd_remove_and_free(qtd), whic			 * dwc_otg_hcd_qtd_remove_and_free(qtd), whic
		 * However, that call frees the qtd memory, a			 * However, that call frees the qtd memory, a
		 * interrupt logic to access it many more tim			 * interrupt logic to access it many more tim
		 * to it.  With slub debugging on, it is clea			 * to it.  With slub debugging on, it is clea
		 * to memory we had freed.					 * to memory we had freed.
		 * Call this instead, and now I have moved th			 * Call this instead, and now I have moved th
		 * the end of processing this interrupt.			 * the end of processing this interrupt.
		 */								 */
		dwc_otg_hcd_qtd_remove(qtd);					dwc_otg_hcd_qtd_remove(qtd);

		continue_split = 0;						continue_split = 0;
	}								}
	_qh->channel = NULL;						_qh->channel = NULL;
	_qh->qtd_in_process = NULL;					_qh->qtd_in_process = NULL;
	dwc_otg_hcd_qh_deactivate(_hcd, _qh, continue_split);		dwc_otg_hcd_qh_deactivate(_hcd, _qh, continue_split);
}								}

/**								/**
 * Updates the state of an Isochronous URB when the transfer 	 * Updates the state of an Isochronous URB when the transfer 
 * any reason. The fields of the current entry in the frame d	 * any reason. The fields of the current entry in the frame d
 * are set based on the transfer state and the input _halt_st	 * are set based on the transfer state and the input _halt_st
 * the Isochronous URB if all the URB frames have been comple	 * the Isochronous URB if all the URB frames have been comple
 *								 *
 * @return DWC_OTG_HC_XFER_COMPLETE if there are more frames 	 * @return DWC_OTG_HC_XFER_COMPLETE if there are more frames 
 * transferred in the URB. Otherwise return DWC_OTG_HC_XFER_U	 * transferred in the URB. Otherwise return DWC_OTG_HC_XFER_U
 */								 */
static dwc_otg_halt_status_e update_isoc_urb_state(dwc_otg_hc	static dwc_otg_halt_status_e update_isoc_urb_state(dwc_otg_hc
	  dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_o		  dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_o
	  dwc_otg_halt_status_e _halt_status)				  dwc_otg_halt_status_e _halt_status)
{								{
	struct urb *urb = _qtd->urb;					struct urb *urb = _qtd->urb;
	dwc_otg_halt_status_e ret_val = _halt_status;			dwc_otg_halt_status_e ret_val = _halt_status;
	struct usb_iso_packet_descriptor *frame_desc;			struct usb_iso_packet_descriptor *frame_desc;
	frame_desc = &urb->iso_frame_desc[_qtd->isoc_frame_in		frame_desc = &urb->iso_frame_desc[_qtd->isoc_frame_in
	switch (_halt_status) {						switch (_halt_status) {
	case DWC_OTG_HC_XFER_COMPLETE:					case DWC_OTG_HC_XFER_COMPLETE:
		frame_desc->status = 0;						frame_desc->status = 0;
		frame_desc->actual_length =					frame_desc->actual_length =
			get_actual_xfer_length(_hc, _hc_regs,				get_actual_xfer_length(_hc, _hc_regs,
		break;								break;
	case DWC_OTG_HC_XFER_FRAME_OVERRUN:				case DWC_OTG_HC_XFER_FRAME_OVERRUN:
		urb->error_count++;						urb->error_count++;
		if (_hc->ep_is_in) {						if (_hc->ep_is_in) {
			frame_desc->status = -ENOSR;					frame_desc->status = -ENOSR;
		} else {							} else {
			frame_desc->status = -ECOMM;					frame_desc->status = -ECOMM;
		}								}
		frame_desc->actual_length = 0;					frame_desc->actual_length = 0;
		break;								break;
	case DWC_OTG_HC_XFER_BABBLE_ERR:				case DWC_OTG_HC_XFER_BABBLE_ERR:
		urb->error_count++;						urb->error_count++;
		frame_desc->status = -EOVERFLOW;				frame_desc->status = -EOVERFLOW;

	    /* Don't need to update actual_length in this cas		    /* Don't need to update actual_length in this cas
	    break;							    break;
	case DWC_OTG_HC_XFER_XACT_ERR:					case DWC_OTG_HC_XFER_XACT_ERR:
		urb->error_count++;						urb->error_count++;
		frame_desc->status = -EPROTO;					frame_desc->status = -EPROTO;
		frame_desc->actual_length =					frame_desc->actual_length =
		    get_actual_xfer_length(_hc, _hc_regs, _qt			    get_actual_xfer_length(_hc, _hc_regs, _qt
	default:							default:
		DWC_ERROR("%s: Unhandled _halt_status (%d)\n"			DWC_ERROR("%s: Unhandled _halt_status (%d)\n"
		BUG();								BUG();
		break;								break;
	}								}
	if (++_qtd->isoc_frame_index == urb->number_of_packet		if (++_qtd->isoc_frame_index == urb->number_of_packet
	    /*								    /*
	     * urb->status is not used for isoc transfers.		     * urb->status is not used for isoc transfers.
	     * The individual frame_desc statuses are used in		     * The individual frame_desc statuses are used in
	     */								     */
	    dwc_otg_hcd_complete_urb(_hcd, urb, 0);			    dwc_otg_hcd_complete_urb(_hcd, urb, 0);
		ret_val = DWC_OTG_HC_XFER_URB_COMPLETE;				ret_val = DWC_OTG_HC_XFER_URB_COMPLETE;
	} else {							} else {
		ret_val = DWC_OTG_HC_XFER_COMPLETE;				ret_val = DWC_OTG_HC_XFER_COMPLETE;
	}								}
	return ret_val;							return ret_val;
}								}

/**								/**
 * Releases a host channel for use by other transfers. Attemp	 * Releases a host channel for use by other transfers. Attemp
 * queue more transactions since at least one host channel is	 * queue more transactions since at least one host channel is
 *								 *
 * @param _hcd The HCD state structure.				 * @param _hcd The HCD state structure.
 * @param _hc The host channel to release.			 * @param _hc The host channel to release.
 * @param _qtd The QTD associated with the host channel. This	 * @param _qtd The QTD associated with the host channel. This
 * if the transfer is complete or an error has occurred.	 * if the transfer is complete or an error has occurred.
 * @param _halt_status Reason the channel is being released. 	 * @param _halt_status Reason the channel is being released. 
 * determines the actions taken by this function.		 * determines the actions taken by this function.
 */								 */

static void release_channel(dwc_otg_hcd_t * _hcd,		static void release_channel(dwc_otg_hcd_t * _hcd,
    dwc_hc_t * _hc, dwc_otg_qtd_t * _qtd, dwc_otg_halt_status	    dwc_hc_t * _hc, dwc_otg_qtd_t * _qtd, dwc_otg_halt_status
	dwc_otg_transaction_type_e tr_type;				dwc_otg_transaction_type_e tr_type;
	int free_qtd;							int free_qtd;
	dwc_otg_qh_t * _qh;						dwc_otg_qh_t * _qh;
	int deact = 1;							int deact = 1;
	int retry_delay = 1;						int retry_delay = 1;
	unsigned long flags;				      <

	DWC_DEBUGPL(DBG_HCDV, "  %s: channel %d, halt_status 		DWC_DEBUGPL(DBG_HCDV, "  %s: channel %d, halt_status 
		      _hc->hc_num, _halt_status);				      _hc->hc_num, _halt_status);
	switch (_halt_status) {						switch (_halt_status) {
	case DWC_OTG_HC_XFER_NYET:					case DWC_OTG_HC_XFER_NYET:
	case DWC_OTG_HC_XFER_NAK:					case DWC_OTG_HC_XFER_NAK:
		if (_halt_status == DWC_OTG_HC_XFER_NYET) {			if (_halt_status == DWC_OTG_HC_XFER_NYET) {
			retry_delay = nyet_deferral_delay;				retry_delay = nyet_deferral_delay;
		} else {							} else {
			retry_delay = nak_deferral_delay;				retry_delay = nak_deferral_delay;
		}								}
		free_qtd = 0;							free_qtd = 0;
		if (deferral_on && _hc->do_split) {				if (deferral_on && _hc->do_split) {
			_qh = _hc->qh;							_qh = _hc->qh;
			if (_qh) {							if (_qh) {
				deact = dwc_otg_hcd_qh_deferr					deact = dwc_otg_hcd_qh_deferr
			}								}
		}								}
	        break;							        break;

	case DWC_OTG_HC_XFER_URB_COMPLETE:				case DWC_OTG_HC_XFER_URB_COMPLETE:
		free_qtd = 1;							free_qtd = 1;
		break;								break;
	case DWC_OTG_HC_XFER_AHB_ERR:					case DWC_OTG_HC_XFER_AHB_ERR:
	case DWC_OTG_HC_XFER_STALL:					case DWC_OTG_HC_XFER_STALL:
	case DWC_OTG_HC_XFER_BABBLE_ERR:				case DWC_OTG_HC_XFER_BABBLE_ERR:
		free_qtd = 1;							free_qtd = 1;
		break;								break;
	case DWC_OTG_HC_XFER_XACT_ERR:					case DWC_OTG_HC_XFER_XACT_ERR:
		if (_qtd->error_count >= 3) {					if (_qtd->error_count >= 3) {
			DWC_DEBUGPL(DBG_HCDV, "  Complete URB				DWC_DEBUGPL(DBG_HCDV, "  Complete URB
			free_qtd = 1;							free_qtd = 1;
			dwc_otg_hcd_complete_urb(_hcd, _qtd->				dwc_otg_hcd_complete_urb(_hcd, _qtd->
		} else {							} else {
			free_qtd = 0;							free_qtd = 0;
		}								}
		break;								break;
	case DWC_OTG_HC_XFER_URB_DEQUEUE:				case DWC_OTG_HC_XFER_URB_DEQUEUE:
	    /*								    /*
	     * The QTD has already been removed and the QH ha		     * The QTD has already been removed and the QH ha
	     * deactivated. Don't want to do anything except 		     * deactivated. Don't want to do anything except 
	     * host channel and try to queue more transfers.		     * host channel and try to queue more transfers.
	     */								     */
	    goto cleanup;						    goto cleanup;
	case DWC_OTG_HC_XFER_NO_HALT_STATUS:				case DWC_OTG_HC_XFER_NO_HALT_STATUS:
#ifdef CONFIG_DWC_DEBUG					      <
		DWC_ERROR("%s: No halt_status, channel %d\n",			DWC_ERROR("%s: No halt_status, channel %d\n",
			   _hc->hc_num);						   _hc->hc_num);
#endif							      <
		free_qtd = 0;							free_qtd = 0;
		break;								break;
	default:							default:
		free_qtd = 0;							free_qtd = 0;
		break;								break;
	}								}
	if (free_qtd) {					      |		*must_free = free_qtd;
		/* Only change must_free to true (do not set  <
		 * pre-initialized to zero).		      <
		 */					      <
		*must_free = 1;				      <
	}						      <
	if (deact) {							if (deact) {
		deactivate_qh(_hcd, _hc->qh, free_qtd);				deactivate_qh(_hcd, _hc->qh, free_qtd);
	}								}
cleanup:							cleanup:
    /*								    /*
     * Release the host channel for use by other transfers. T	     * Release the host channel for use by other transfers. T
     * function clears the channel interrupt enables and cond	     * function clears the channel interrupt enables and cond
     * there's no need to clear the Channel Halted interrupt 	     * there's no need to clear the Channel Halted interrupt 
     */								     */
    dwc_otg_hc_cleanup(_hcd->core_if, _hc);			    dwc_otg_hc_cleanup(_hcd->core_if, _hc);
	list_add_tail(&_hc->hc_list_entry, &_hcd->free_hc_lis		list_add_tail(&_hc->hc_list_entry, &_hcd->free_hc_lis
	local_irq_save(flags);				      |		switch (_hc->ep_type) {
	_hcd->available_host_channels++;		      |		case DWC_OTG_EP_TYPE_CONTROL:
	local_irq_restore(flags);			      |		case DWC_OTG_EP_TYPE_BULK:
							      |			_hcd->non_periodic_channels--;
							      >			break;
							      >		default:
							      >		    /*
							      >		     * Don't release reservations for periodic channe
							      >		     * That's done when a periodic transfer is desche
							      >		     * when the QH is removed from the periodic sched
							      >		     */
							      >		    break;
							      >		}
	/* Try to queue more transfers now that there's a fre		/* Try to queue more transfers now that there's a fre
	/* unless erratum_usb09_patched is set */			/* unless erratum_usb09_patched is set */
	if (!erratum_usb09_patched) {					if (!erratum_usb09_patched) {
		tr_type = dwc_otg_hcd_select_transactions(_hc			tr_type = dwc_otg_hcd_select_transactions(_hc
		if (tr_type != DWC_OTG_TRANSACTION_NONE) {			if (tr_type != DWC_OTG_TRANSACTION_NONE) {
			dwc_otg_hcd_queue_transactions(_hcd, 				dwc_otg_hcd_queue_transactions(_hcd, 
		}								}
	}								}
}								}

/**								/**
 * Halts a host channel. If the channel cannot be halted imme	 * Halts a host channel. If the channel cannot be halted imme
 * the request queue is full, this function ensures that the 	 * the request queue is full, this function ensures that the 
 * interrupt for the appropriate queue is enabled so that the	 * interrupt for the appropriate queue is enabled so that the
 * be queued when there is space in the request queue.		 * be queued when there is space in the request queue.
 *								 *
 * This function may also be called in DMA mode. In that case	 * This function may also be called in DMA mode. In that case
 * simply released since the core always halts the channel au	 * simply released since the core always halts the channel au
 * DMA mode.							 * DMA mode.
 */								 */
static void halt_channel(dwc_otg_hcd_t * _hcd,			static void halt_channel(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_qtd_t * _qtd, dwc_otg_halt_st		dwc_hc_t * _hc, dwc_otg_qtd_t * _qtd, dwc_otg_halt_st
{								{
	if (_hcd->core_if->dma_enable) {				if (_hcd->core_if->dma_enable) {
		release_channel(_hcd, _hc, _qtd, _halt_status			release_channel(_hcd, _hc, _qtd, _halt_status
		return;								return;
	}								}

    /* Slave mode processing... */				    /* Slave mode processing... */
    dwc_otg_hc_halt(_hcd->core_if, _hc, _halt_status);		    dwc_otg_hc_halt(_hcd->core_if, _hc, _halt_status);
	if (_hc->halt_on_queue) {					if (_hc->halt_on_queue) {
		gintmsk_data_t gintmsk = {.d32 = 0};				gintmsk_data_t gintmsk = {.d32 = 0};
		dwc_otg_core_global_regs_t * global_regs;			dwc_otg_core_global_regs_t * global_regs;
		global_regs = _hcd->core_if->core_global_regs			global_regs = _hcd->core_if->core_global_regs
		if (_hc->ep_type == DWC_OTG_EP_TYPE_CONTROL |			if (_hc->ep_type == DWC_OTG_EP_TYPE_CONTROL |
			_hc->ep_type == DWC_OTG_EP_TYPE_BULK)				_hc->ep_type == DWC_OTG_EP_TYPE_BULK)
		    /*								    /*
		     * Make sure the Non-periodic Tx FIFO emp			     * Make sure the Non-periodic Tx FIFO emp
		     * is enabled so that the non-periodic sc			     * is enabled so that the non-periodic sc
		     * be processed.						     * be processed.
		     */								     */
		    gintmsk.b.nptxfempty = 1;					    gintmsk.b.nptxfempty = 1;
			dwc_modify_reg32(&global_regs->gintms				dwc_modify_reg32(&global_regs->gintms
		} else {							} else {
		    /*								    /*
		     * Move the QH from the periodic queued s			     * Move the QH from the periodic queued s
		     * the periodic assigned schedule. This a			     * the periodic assigned schedule. This a
		     * halt to be queued when the periodic sc			     * halt to be queued when the periodic sc
		     * processed.						     * processed.
		     */								     */
		    list_move(&_hc->qh->qh_list_entry,				    list_move(&_hc->qh->qh_list_entry,
			      &_hcd->periodic_sched_assigned)				      &_hcd->periodic_sched_assigned)

		    /*								    /*
		     * Make sure the Periodic Tx FIFO Empty i			     * Make sure the Periodic Tx FIFO Empty i
		     * enabled so that the periodic schedule 			     * enabled so that the periodic schedule 
		     * processed.						     * processed.
		     */								     */
		    gintmsk.b.ptxfempty = 1;					    gintmsk.b.ptxfempty = 1;
			dwc_modify_reg32(&global_regs->gintms				dwc_modify_reg32(&global_regs->gintms
		}								}
	}								}
}								}

/**								/**
 * Performs common cleanup for non-periodic transfers after a	 * Performs common cleanup for non-periodic transfers after a
 * Complete interrupt. This function should be called after a	 * Complete interrupt. This function should be called after a
 * specific handling is finished to release the host channel.	 * specific handling is finished to release the host channel.
 */								 */
static void complete_non_periodic_xfer(dwc_otg_hcd_t * _hcd,	static void complete_non_periodic_xfer(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
	dwc_otg_halt_status_e _halt_status, int *must_free)		dwc_otg_halt_status_e _halt_status, int *must_free)
{								{
	hcint_data_t hcint;						hcint_data_t hcint;
	_qtd->error_count = 0;						_qtd->error_count = 0;
	hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);			hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
	if (hcint.b.nyet) {						if (hcint.b.nyet) {
	    /*								    /*
	     * Got a NYET on the last transaction of the tran		     * Got a NYET on the last transaction of the tran
	     * means that the endpoint should be in the PING 		     * means that the endpoint should be in the PING 
	     * beginning of the next transfer.				     * beginning of the next transfer.
	     */								     */
	    _hc->qh->ping_state = 1;					    _hc->qh->ping_state = 1;
		clear_hc_int(_hc_regs, nyet);					clear_hc_int(_hc_regs, nyet);
	}								}

    /*								    /*
     * Always halt and release the host channel to make it av	     * Always halt and release the host channel to make it av
     * more transfers. There may still be more phases for a c	     * more transfers. There may still be more phases for a c
     * transfer or more data packets for a bulk transfer at t	     * transfer or more data packets for a bulk transfer at t
     * but the host channel is still halted. A channel will b	     * but the host channel is still halted. A channel will b
     * to the transfer when the non-periodic schedule is proc	     * to the transfer when the non-periodic schedule is proc
     * the channel is released. This allows transactions to b	     * the channel is released. This allows transactions to b
     * properly via dwc_otg_hcd_queue_transactions, which als	     * properly via dwc_otg_hcd_queue_transactions, which als
     * Tx FIFO Empty interrupt if necessary.			     * Tx FIFO Empty interrupt if necessary.
     */								     */
    if (_hc->ep_is_in) {					    if (_hc->ep_is_in) {
	    /*								    /*
	     * IN transfers in Slave mode require an explicit		     * IN transfers in Slave mode require an explicit
	     * halt the channel. (In DMA mode, this call simp		     * halt the channel. (In DMA mode, this call simp
	     * the channel.)						     * the channel.)
	     */								     */
	    halt_channel(_hcd, _hc, _qtd, _halt_status, must_		    halt_channel(_hcd, _hc, _qtd, _halt_status, must_
	} else {							} else {
	    /*								    /*
	     * The channel is automatically disabled by the c		     * The channel is automatically disabled by the c
	     * transfers in Slave mode.					     * transfers in Slave mode.
	     */								     */
	    release_channel(_hcd, _hc, _qtd, _halt_status, mu		    release_channel(_hcd, _hc, _qtd, _halt_status, mu
	}								}
}								}

/**								/**
 * Performs common cleanup for periodic transfers after a Tra	 * Performs common cleanup for periodic transfers after a Tra
 * interrupt. This function should be called after any endpoi	 * interrupt. This function should be called after any endpoi
 * handling is finished to release the host channel.		 * handling is finished to release the host channel.
 */								 */
static void complete_periodic_xfer(dwc_otg_hcd_t * _hcd,	static void complete_periodic_xfer(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
	dwc_otg_halt_status_e _halt_status, int *must_free)		dwc_otg_halt_status_e _halt_status, int *must_free)
{								{
	hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
	_qtd->error_count = 0;						_qtd->error_count = 0;
	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
	if (!_hc->ep_is_in || hctsiz.b.pktcnt == 0) {			if (!_hc->ep_is_in || hctsiz.b.pktcnt == 0) {
	    /* Core halts channel in these cases. */			    /* Core halts channel in these cases. */
	    release_channel(_hcd, _hc, _qtd, _halt_status, mu		    release_channel(_hcd, _hc, _qtd, _halt_status, mu
	} else {							} else {
	    /* Flush any outstanding requests from the Tx que		    /* Flush any outstanding requests from the Tx que
	    halt_channel(_hcd, _hc, _qtd, _halt_status, must_		    halt_channel(_hcd, _hc, _qtd, _halt_status, must_
	}								}
}								}

/**								/**
 * Handles a host channel Transfer Complete interrupt. This h	 * Handles a host channel Transfer Complete interrupt. This h
 * called in either DMA mode or Slave mode.			 * called in either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_xfercomp_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	int urb_xfer_done;						int urb_xfer_done;
	dwc_otg_halt_status_e halt_status = DWC_OTG_HC_XFER_C		dwc_otg_halt_status_e halt_status = DWC_OTG_HC_XFER_C
	struct urb *urb = _qtd->urb;					struct urb *urb = _qtd->urb;
	int pipe_type = usb_pipetype(urb->pipe);			int pipe_type = usb_pipetype(urb->pipe);
	int status = -EINPROGRESS;					int status = -EINPROGRESS;

	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		      "Transfer Complete--\n", _hc->hc_num);			      "Transfer Complete--\n", _hc->hc_num);

    /*								    /*
     * Handle xfer complete on CSPLIT.				     * Handle xfer complete on CSPLIT.
     */								     */
    if (_hc->qh->do_split) {					    if (_hc->qh->do_split) {
		_qtd->complete_split = 0;					_qtd->complete_split = 0;
	}								}

    /* Update the QTD and URB states. */			    /* Update the QTD and URB states. */
    switch (pipe_type) {					    switch (pipe_type) {
	case PIPE_CONTROL:						case PIPE_CONTROL:
		switch (_qtd->control_phase) {					switch (_qtd->control_phase) {
		case DWC_OTG_CONTROL_SETUP:					case DWC_OTG_CONTROL_SETUP:
			if (urb->transfer_buffer_length > 0) 				if (urb->transfer_buffer_length > 0) 
				_qtd->control_phase = DWC_OTG					_qtd->control_phase = DWC_OTG
			} else {							} else {
				_qtd->control_phase = DWC_OTG					_qtd->control_phase = DWC_OTG
			}								}
			DWC_DEBUGPL(DBG_HCDV,						DWC_DEBUGPL(DBG_HCDV,
				     "  Control setup transac					     "  Control setup transac
			halt_status = DWC_OTG_HC_XFER_COMPLET				halt_status = DWC_OTG_HC_XFER_COMPLET
			break;								break;
		case DWC_OTG_CONTROL_DATA:{					case DWC_OTG_CONTROL_DATA:{
			urb_xfer_done = update_urb_state_xfer				urb_xfer_done = update_urb_state_xfer
				if (urb_xfer_done) {						if (urb_xfer_done) {
					_qtd->control_phase =						_qtd->control_phase =
					DWC_DEBUGPL(DBG_HCDV,						DWC_DEBUGPL(DBG_HCDV,
				} else {							} else {
					save_data_toggle(_hc,						save_data_toggle(_hc,
				}								}
				halt_status = DWC_OTG_HC_XFER					halt_status = DWC_OTG_HC_XFER
				break;								break;
			}								}
		case DWC_OTG_CONTROL_STATUS:					case DWC_OTG_CONTROL_STATUS:
			DWC_DEBUGPL(DBG_HCDV, "  Control tran				DWC_DEBUGPL(DBG_HCDV, "  Control tran
			if (status == -EINPROGRESS) {					if (status == -EINPROGRESS) {
				status = 0;							status = 0;
			}								}
			dwc_otg_hcd_complete_urb(_hcd, urb, s				dwc_otg_hcd_complete_urb(_hcd, urb, s
			halt_status = DWC_OTG_HC_XFER_URB_COM				halt_status = DWC_OTG_HC_XFER_URB_COM
			break;								break;
		}								}
		complete_non_periodic_xfer(_hcd, _hc, _hc_reg			complete_non_periodic_xfer(_hcd, _hc, _hc_reg
					     halt_status, mus						     halt_status, mus
		break;								break;
	case PIPE_BULK:							case PIPE_BULK:
		DWC_DEBUGPL(DBG_HCDV, "  Bulk transfer comple			DWC_DEBUGPL(DBG_HCDV, "  Bulk transfer comple
		urb_xfer_done = update_urb_state_xfer_comp(_h			urb_xfer_done = update_urb_state_xfer_comp(_h
		if (urb_xfer_done) {						if (urb_xfer_done) {
			dwc_otg_hcd_complete_urb(_hcd, urb, s				dwc_otg_hcd_complete_urb(_hcd, urb, s
			halt_status = DWC_OTG_HC_XFER_URB_COM				halt_status = DWC_OTG_HC_XFER_URB_COM
		} else {							} else {
			halt_status = DWC_OTG_HC_XFER_COMPLET				halt_status = DWC_OTG_HC_XFER_COMPLET
		}								}
		save_data_toggle(_hc, _hc_regs, _qtd);				save_data_toggle(_hc, _hc_regs, _qtd);
		complete_non_periodic_xfer(_hcd, _hc, _hc_reg			complete_non_periodic_xfer(_hcd, _hc, _hc_reg
		break;								break;
	case PIPE_INTERRUPT:						case PIPE_INTERRUPT:
		DWC_DEBUGPL(DBG_HCDV, "  Interrupt transfer c			DWC_DEBUGPL(DBG_HCDV, "  Interrupt transfer c
		update_urb_state_xfer_comp(_hc, _hc_regs, urb			update_urb_state_xfer_comp(_hc, _hc_regs, urb
	    /*								    /*
	     * Interrupt URB is done on the first transfer co		     * Interrupt URB is done on the first transfer co
	     * interrupt.						     * interrupt.
	     */								     */
	    dwc_otg_hcd_complete_urb(_hcd, urb, status);		    dwc_otg_hcd_complete_urb(_hcd, urb, status);
		save_data_toggle(_hc, _hc_regs, _qtd);				save_data_toggle(_hc, _hc_regs, _qtd);
		complete_periodic_xfer(_hcd, _hc, _hc_regs, _			complete_periodic_xfer(_hcd, _hc, _hc_regs, _
					DWC_OTG_HC_XFER_URB_C						DWC_OTG_HC_XFER_URB_C
		break;								break;
	case PIPE_ISOCHRONOUS:						case PIPE_ISOCHRONOUS:
		DWC_DEBUGPL(DBG_HCDV, "  Isochronous transfer			DWC_DEBUGPL(DBG_HCDV, "  Isochronous transfer
		if (_qtd->isoc_split_pos == DWC_HCSPLIT_XACTP			if (_qtd->isoc_split_pos == DWC_HCSPLIT_XACTP
			halt_status = update_isoc_urb_state(_				halt_status = update_isoc_urb_state(_
							  DWC								  DWC
		}								}
		complete_periodic_xfer(_hcd, _hc, _hc_regs, _			complete_periodic_xfer(_hcd, _hc, _hc_regs, _
		break;								break;
	}								}
	disable_hc_int(_hc_regs, xfercompl);				disable_hc_int(_hc_regs, xfercompl);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel STALL interrupt. This handler may b	 * Handles a host channel STALL interrupt. This handler may b
 * either DMA mode or Slave mode.				 * either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_stall_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_stall_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	struct urb *urb = _qtd->urb;					struct urb *urb = _qtd->urb;
	int pipe_type = usb_pipetype(urb->pipe);			int pipe_type = usb_pipetype(urb->pipe);
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		      "STALL Received--\n", _hc->hc_num);			      "STALL Received--\n", _hc->hc_num);
	if (pipe_type == PIPE_CONTROL) {				if (pipe_type == PIPE_CONTROL) {
		dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EP			dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EP
	}								}
	if (pipe_type == PIPE_BULK || pipe_type == PIPE_INTER		if (pipe_type == PIPE_BULK || pipe_type == PIPE_INTER
		dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EP			dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EP
	    /*								    /*
	     * USB protocol requires resetting the data toggl		     * USB protocol requires resetting the data toggl
	     * and interrupt endpoints when a CLEAR_FEATURE(E		     * and interrupt endpoints when a CLEAR_FEATURE(E
	     * setup command is issued to the endpoint. Antic		     * setup command is issued to the endpoint. Antic
	     * CLEAR_FEATURE command since a STALL has occurr		     * CLEAR_FEATURE command since a STALL has occurr
	     * the data toggle now.					     * the data toggle now.
	     */								     */
	    _hc->qh->data_toggle = 0;					    _hc->qh->data_toggle = 0;
	}								}
	halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_STALL, 		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_STALL, 
	disable_hc_int(_hc_regs, stall);				disable_hc_int(_hc_regs, stall);
	return 1;							return 1;
}								}

/*								/*
 * Updates the state of the URB when a transfer has been stop	 * Updates the state of the URB when a transfer has been stop
 * abnormal condition before the transfer completes. Modifies	 * abnormal condition before the transfer completes. Modifies
 * actual_length field of the URB to reflect the number of by	 * actual_length field of the URB to reflect the number of by
 * actually been transferred via the host channel.		 * actually been transferred via the host channel.
 */								 */
static void update_urb_state_xfer_intr(dwc_hc_t * _hc,		static void update_urb_state_xfer_intr(dwc_hc_t * _hc,
	dwc_otg_hc_regs_t * _hc_regs, struct urb *_urb, dwc_o		dwc_otg_hc_regs_t * _hc_regs, struct urb *_urb, dwc_o
	dwc_otg_halt_status_e _halt_status)				dwc_otg_halt_status_e _halt_status)
{								{
	uint32_t bytes_transferred =					uint32_t bytes_transferred =
	    get_actual_xfer_length(_hc, _hc_regs, _qtd, _halt		    get_actual_xfer_length(_hc, _hc_regs, _qtd, _halt
	_urb->actual_length += bytes_transferred;			_urb->actual_length += bytes_transferred;

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
	{								{
		hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
		hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz
		DWC_DEBUGPL(DBG_HCDV, "DWC_otg: %s: %s, chann			DWC_DEBUGPL(DBG_HCDV, "DWC_otg: %s: %s, chann
			     __func__, (_hc->ep_is_in ? "IN" 				     __func__, (_hc->ep_is_in ? "IN" 
		DWC_DEBUGPL(DBG_HCDV, "  _hc->start_pkt_count			DWC_DEBUGPL(DBG_HCDV, "  _hc->start_pkt_count
			     _hc->start_pkt_count);					     _hc->start_pkt_count);
		DWC_DEBUGPL(DBG_HCDV, "  hctsiz.pktcnt %d\n",			DWC_DEBUGPL(DBG_HCDV, "  hctsiz.pktcnt %d\n",
		DWC_DEBUGPL(DBG_HCDV, "  _hc->max_packet %d\n			DWC_DEBUGPL(DBG_HCDV, "  _hc->max_packet %d\n
		DWC_DEBUGPL(DBG_HCDV, "  bytes_transferred %d			DWC_DEBUGPL(DBG_HCDV, "  bytes_transferred %d
			     bytes_transferred);					     bytes_transferred);
		DWC_DEBUGPL(DBG_HCDV, "  _urb->actual_length 			DWC_DEBUGPL(DBG_HCDV, "  _urb->actual_length 
			     _urb->actual_length);					     _urb->actual_length);
		DWC_DEBUGPL(DBG_HCDV, "  _urb->transfer_buffe			DWC_DEBUGPL(DBG_HCDV, "  _urb->transfer_buffe
			     _urb->transfer_buffer_length);				     _urb->transfer_buffer_length);
	}								}
#endif	/*  */							#endif	/*  */
}								}

/**								/**
 * Handles a host channel NAK interrupt. This handler may be 	 * Handles a host channel NAK interrupt. This handler may be 
 * DMA mode or Slave mode.					 * DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_nak_intr(dwc_otg_hcd_t * _hcd,		static int32_t handle_hc_nak_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "NAK Received--\n", _hc->hc_num);				     "NAK Received--\n", _hc->hc_num);
    /*								    /*
     * Handle NAK for IN/OUT SSPLIT/CSPLIT transfers, bulk, c	     * Handle NAK for IN/OUT SSPLIT/CSPLIT transfers, bulk, c
     * interrupt.  Re-start the SSPLIT transfer.		     * interrupt.  Re-start the SSPLIT transfer.
     */								     */
    if (_hc->do_split) {					    if (_hc->do_split) {
		if (_hc->complete_split) {					if (_hc->complete_split) {
			_qtd->error_count = 0;						_qtd->error_count = 0;
		}								}
		_qtd->complete_split = 0;					_qtd->complete_split = 0;
		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER
		goto handle_nak_done;						goto handle_nak_done;
	}								}
	switch (usb_pipetype(_qtd->urb->pipe)) {			switch (usb_pipetype(_qtd->urb->pipe)) {
	case PIPE_CONTROL:						case PIPE_CONTROL:
	case PIPE_BULK:							case PIPE_BULK:
		if (_hcd->core_if->dma_enable && _hc->ep_is_i			if (_hcd->core_if->dma_enable && _hc->ep_is_i
		    /*								    /*
		     * NAK interrupts are enabled on bulk/con			     * NAK interrupts are enabled on bulk/con
		     * transfers in DMA mode for the sole pur			     * transfers in DMA mode for the sole pur
		     * resetting the error count after a tran			     * resetting the error count after a tran
		     * occurs. The core will continue transfe			     * occurs. The core will continue transfe
		     */								     */
		    _qtd->error_count = 0;					    _qtd->error_count = 0;
			goto handle_nak_done;						goto handle_nak_done;
		}								}

	    /*								    /*
	     * NAK interrupts normally occur during OUT trans		     * NAK interrupts normally occur during OUT trans
	     * or Slave mode. For IN transfers, more requests		     * or Slave mode. For IN transfers, more requests
	     * queued as request queue space is available.		     * queued as request queue space is available.
	     */								     */
	    _qtd->error_count = 0;					    _qtd->error_count = 0;
		if (!_hc->qh->ping_state) {					if (!_hc->qh->ping_state) {
			update_urb_state_xfer_intr(_hc, _hc_r				update_urb_state_xfer_intr(_hc, _hc_r
						    _qtd, DWC							    _qtd, DWC
			save_data_toggle(_hc, _hc_regs, _qtd)				save_data_toggle(_hc, _hc_regs, _qtd)
			if (_qtd->urb->dev->speed == USB_SPEE				if (_qtd->urb->dev->speed == USB_SPEE
				_hc->qh->ping_state = 1;					_hc->qh->ping_state = 1;
			}								}
		}								}

	    /*								    /*
	     * Halt the channel so the transfer can be re-sta		     * Halt the channel so the transfer can be re-sta
	     * the appropriate point or the PING protocol wil		     * the appropriate point or the PING protocol wil
	     * start/continue.						     * start/continue.
	     */								     */
	    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NAK		    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NAK
		break;								break;
	case PIPE_INTERRUPT:						case PIPE_INTERRUPT:
		_qtd->error_count = 0;						_qtd->error_count = 0;
		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER
		break;								break;
	case PIPE_ISOCHRONOUS:						case PIPE_ISOCHRONOUS:
	    /* Should never get called for isochronous transf		    /* Should never get called for isochronous transf
		BUG();								BUG();
		break;								break;
	}								}
	handle_nak_done:disable_hc_int(_hc_regs, nak);			handle_nak_done:disable_hc_int(_hc_regs, nak);
							      >		clear_hc_int(_hc_regs, nak);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel ACK interrupt. This interrupt is en	 * Handles a host channel ACK interrupt. This interrupt is en
 * performing the PING protocol in Slave mode, when errors oc	 * performing the PING protocol in Slave mode, when errors oc
 * either Slave mode or DMA mode, and during Start Split tran	 * either Slave mode or DMA mode, and during Start Split tran
 */								 */
static int32_t handle_hc_ack_intr(dwc_otg_hcd_t * _hcd,		static int32_t handle_hc_ack_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "ACK Received--\n", _hc->hc_num);				     "ACK Received--\n", _hc->hc_num);
	if (_hc->do_split) {						if (_hc->do_split) {
	    /*								    /*
	     * Handle ACK on SSPLIT.					     * Handle ACK on SSPLIT.
	     * ACK should not occur in CSPLIT.				     * ACK should not occur in CSPLIT.
	     */								     */
	    if ((!_hc->ep_is_in) && (_hc->data_pid_start != D		    if ((!_hc->ep_is_in) && (_hc->data_pid_start != D
			_qtd->ssplit_out_xfer_count = _hc->xf				_qtd->ssplit_out_xfer_count = _hc->xf
		}								}
		if (!(_hc->ep_type == DWC_OTG_EP_TYPE_ISOC &&			if (!(_hc->ep_type == DWC_OTG_EP_TYPE_ISOC &&
			    /* Don't need complete for isochr				    /* Don't need complete for isochr
			    _qtd->complete_split = 1;					    _qtd->complete_split = 1;
		}								}

	    /* ISOC OUT */						    /* ISOC OUT */
	    if ((_hc->ep_type == DWC_OTG_EP_TYPE_ISOC) && !_h		    if ((_hc->ep_type == DWC_OTG_EP_TYPE_ISOC) && !_h
			switch (_hc->xact_pos) {					switch (_hc->xact_pos) {
			case DWC_HCSPLIT_XACTPOS_ALL:					case DWC_HCSPLIT_XACTPOS_ALL:
				break;								break;
			case DWC_HCSPLIT_XACTPOS_END:					case DWC_HCSPLIT_XACTPOS_END:
				_qtd->isoc_split_pos = DWC_HC					_qtd->isoc_split_pos = DWC_HC
				_qtd->isoc_split_offset = 0;					_qtd->isoc_split_offset = 0;
				break;								break;
			case DWC_HCSPLIT_XACTPOS_BEGIN:					case DWC_HCSPLIT_XACTPOS_BEGIN:
			case DWC_HCSPLIT_XACTPOS_MID:					case DWC_HCSPLIT_XACTPOS_MID:
			    /*								    /*
			     * For BEGIN or MID, calculate th				     * For BEGIN or MID, calculate th
			     * the next microframe to determi				     * the next microframe to determi
			     * SSPLIT token, either MID or EN				     * SSPLIT token, either MID or EN
			     */								     */
			    do {							    do {
					struct usb_iso_packet						struct usb_iso_packet
					frame_desc = &_qtd->u						frame_desc = &_qtd->u
					_qtd->isoc_split_offs						_qtd->isoc_split_offs
					if ((frame_desc->leng						if ((frame_desc->leng
						_qtd->isoc_sp							_qtd->isoc_sp
					} else {							} else {
						_qtd->isoc_sp							_qtd->isoc_sp
					}								}
				} while (0);							} while (0);
				break;								break;
			}								}
		} else {							} else {
			halt_channel(_hcd, _hc, _qtd, DWC_OTG				halt_channel(_hcd, _hc, _qtd, DWC_OTG
		}								}
	} else {							} else {
		_qtd->error_count = 0;						_qtd->error_count = 0;
		if (_hc->qh->ping_state) {					if (_hc->qh->ping_state) {
			_hc->qh->ping_state = 0;					_hc->qh->ping_state = 0;

		    /*								    /*
		     * Halt the channel so the transfer can b			     * Halt the channel so the transfer can b
		     * from the appropriate point. This only 			     * from the appropriate point. This only 
		     * Slave mode. In DMA mode, the ping_stat			     * Slave mode. In DMA mode, the ping_stat
		     * when the transfer is started because t			     * when the transfer is started because t
		     * automatically executes the PING, then 			     * automatically executes the PING, then 
		     */								     */
		    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_			    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_
		} else {				      <
		    halt_channel(_hcd, _hc, _qtd, _hc->halt_s <
		}								}
	}								}

    /*								    /*
     * If the ACK occurred when _not_ in the PING state, let 	     * If the ACK occurred when _not_ in the PING state, let 
     * continue transferring data after clearing the error co	     * continue transferring data after clearing the error co
     */								     */
    disable_hc_int(_hc_regs, ack);				    disable_hc_int(_hc_regs, ack);
							      >		clear_hc_int(_hc_regs, ack);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel NYET interrupt. This interrupt shou	 * Handles a host channel NYET interrupt. This interrupt shou
 * Bulk and Control OUT endpoints and for complete split tran	 * Bulk and Control OUT endpoints and for complete split tran
 * NYET occurs at the same time as a Transfer Complete interr	 * NYET occurs at the same time as a Transfer Complete interr
 * handled in the xfercomp interrupt handler, not here. This 	 * handled in the xfercomp interrupt handler, not here. This 
 * called in either DMA mode or Slave mode.			 * called in either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_nyet_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "NYET Received--\n", _hc->hc_num);				     "NYET Received--\n", _hc->hc_num);

    /*								    /*
     * NYET on CSPLIT						     * NYET on CSPLIT
     * re-do the CSPLIT immediately on non-periodic		     * re-do the CSPLIT immediately on non-periodic
     */								     */
    if ((_hc->do_split) && (_hc->complete_split)) {		    if ((_hc->do_split) && (_hc->complete_split)) {
		if ((_hc->ep_type == DWC_OTG_EP_TYPE_INTR) ||			if ((_hc->ep_type == DWC_OTG_EP_TYPE_INTR) ||
		     (_hc->ep_type == DWC_OTG_EP_TYPE_ISOC)) 			     (_hc->ep_type == DWC_OTG_EP_TYPE_ISOC)) 
			int frnum = dwc_otg_hcd_get_frame_num				int frnum = dwc_otg_hcd_get_frame_num
							 (_hc								 (_hc
			if (dwc_full_frame_num(frnum) !=				if (dwc_full_frame_num(frnum) !=
			      dwc_full_frame_num(_hc->qh->sch				      dwc_full_frame_num(_hc->qh->sch

			    /*								    /*
			     * No longer in the same full spe				     * No longer in the same full spe
			     * Treat this as a transaction er				     * Treat this as a transaction er
			     */								     */
#if 0								#if 0
				/** @todo Fix system performa					/** @todo Fix system performa
				 * be treated as an error. Ri					 * be treated as an error. Ri
				 * splits cannot be scheduled					 * splits cannot be scheduled
				 * due to other system activi					 * due to other system activi
				 * occurs regularly in Slave 					 * occurs regularly in Slave 
				 */								 */
				    _qtd->error_count++;					    _qtd->error_count++;

#endif	/*  */							#endif	/*  */
			    _qtd->complete_split = 0;					    _qtd->complete_split = 0;
				halt_channel(_hcd, _hc, _qtd,					halt_channel(_hcd, _hc, _qtd,

				/** @todo add support for iso					/** @todo add support for iso
			    goto handle_nyet_done;					    goto handle_nyet_done;
			}								}
		}								}
		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER
		goto handle_nyet_done;						goto handle_nyet_done;
	}								}
	_hc->qh->ping_state = 1;					_hc->qh->ping_state = 1;
	_qtd->error_count = 0;						_qtd->error_count = 0;
	update_urb_state_xfer_intr(_hc, _hc_regs, _qtd->urb, 		update_urb_state_xfer_intr(_hc, _hc_regs, _qtd->urb, 
				     DWC_OTG_HC_XFER_NYET);					     DWC_OTG_HC_XFER_NYET);
	save_data_toggle(_hc, _hc_regs, _qtd);				save_data_toggle(_hc, _hc_regs, _qtd);

    /*								    /*
     * Halt the channel and re-start the transfer so the PING	     * Halt the channel and re-start the transfer so the PING
     * protocol will start.					     * protocol will start.
     */								     */
    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NYET, must_	    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_NYET, must_
handle_nyet_done:						handle_nyet_done:
	disable_hc_int(_hc_regs, nyet);					disable_hc_int(_hc_regs, nyet);
	clear_hc_int(_hc_regs, nyet);					clear_hc_int(_hc_regs, nyet);

	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel babble interrupt. This handler may 	 * Handles a host channel babble interrupt. This handler may 
 * either DMA mode or Slave mode.				 * either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_babble_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_babble_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "Babble Error--\n", _hc->hc_num);				     "Babble Error--\n", _hc->hc_num);
	if (_hc->ep_type != DWC_OTG_EP_TYPE_ISOC) {			if (_hc->ep_type != DWC_OTG_EP_TYPE_ISOC) {
		dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EO			dwc_otg_hcd_complete_urb(_hcd, _qtd->urb, -EO
		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER
	} else {							} else {
		dwc_otg_halt_status_e halt_status;				dwc_otg_halt_status_e halt_status;
		halt_status = update_isoc_urb_state(_hcd, _hc			halt_status = update_isoc_urb_state(_hcd, _hc
					  DWC_OTG_HC_XFER_BAB						  DWC_OTG_HC_XFER_BAB
		halt_channel(_hcd, _hc, _qtd, halt_status, mu			halt_channel(_hcd, _hc, _qtd, halt_status, mu
	}								}
	disable_hc_int(_hc_regs, bblerr);				disable_hc_int(_hc_regs, bblerr);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel AHB error interrupt. This handler i	 * Handles a host channel AHB error interrupt. This handler i
 * DMA mode.							 * DMA mode.
 */								 */
static int32_t handle_hc_ahberr_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_ahberr_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	hcchar_data_t hcchar;						hcchar_data_t hcchar;
	hcsplt_data_t hcsplt;						hcsplt_data_t hcsplt;
	hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
	uint32_t hcdma;							uint32_t hcdma;
	struct urb *urb = _qtd->urb;					struct urb *urb = _qtd->urb;
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		      "AHB Error--\n", _hc->hc_num);				      "AHB Error--\n", _hc->hc_num);
	hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);			hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);
	hcsplt.d32 = dwc_read_reg32(&_hc_regs->hcsplt);			hcsplt.d32 = dwc_read_reg32(&_hc_regs->hcsplt);
	hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz);
	hcdma = dwc_read_reg32(&_hc_regs->hcdma);			hcdma = dwc_read_reg32(&_hc_regs->hcdma);
	DWC_ERROR("AHB ERROR, Channel %d\n", _hc->hc_num);		DWC_ERROR("AHB ERROR, Channel %d\n", _hc->hc_num);
	DWC_ERROR("  hcchar 0x%08x, hcsplt 0x%08x\n", hcchar.		DWC_ERROR("  hcchar 0x%08x, hcsplt 0x%08x\n", hcchar.
	DWC_ERROR("  hctsiz 0x%08x, hcdma 0x%08x\n", hctsiz.d		DWC_ERROR("  hctsiz 0x%08x, hcdma 0x%08x\n", hctsiz.d
	DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD URB Enqueue\n");		DWC_DEBUGPL(DBG_HCD, "DWC OTG HCD URB Enqueue\n");
	DWC_ERROR("  Device address: %d\n", usb_pipedevice(ur		DWC_ERROR("  Device address: %d\n", usb_pipedevice(ur
	DWC_ERROR("  Endpoint: %d, %s\n", usb_pipeendpoint(ur		DWC_ERROR("  Endpoint: %d, %s\n", usb_pipeendpoint(ur
			(usb_pipein(urb->pipe) ? "IN" : "OUT"				(usb_pipein(urb->pipe) ? "IN" : "OUT"
	DWC_ERROR("  Endpoint type: %s\n", ( {				DWC_ERROR("  Endpoint type: %s\n", ( {
			char *pipetype;							char *pipetype;
		    switch (usb_pipetype(urb->pipe)) {				    switch (usb_pipetype(urb->pipe)) {
			case PIPE_CONTROL:						case PIPE_CONTROL:
				pipetype = "CONTROL"; break;					pipetype = "CONTROL"; break;
			case PIPE_BULK:							case PIPE_BULK:
				pipetype = "BULK"; break;					pipetype = "BULK"; break;
			case PIPE_INTERRUPT:						case PIPE_INTERRUPT:
				pipetype = "INTERRUPT"; break					pipetype = "INTERRUPT"; break
			case PIPE_ISOCHRONOUS:						case PIPE_ISOCHRONOUS:
				pipetype = "ISOCHRONOUS"; bre					pipetype = "ISOCHRONOUS"; bre
			default:							default:
				pipetype = "UNKNOWN"; break;					pipetype = "UNKNOWN"; break;
			};								};
			pipetype;							pipetype;
	} )) ;								} )) ;
	DWC_ERROR("  Speed: %s\n", ( {					DWC_ERROR("  Speed: %s\n", ( {
			char *speed;							char *speed;
			switch (urb->dev->speed) {					switch (urb->dev->speed) {
			case USB_SPEED_HIGH:						case USB_SPEED_HIGH:
				speed = "HIGH"; break;						speed = "HIGH"; break;
			case USB_SPEED_FULL:						case USB_SPEED_FULL:
				speed = "FULL"; break;						speed = "FULL"; break;
			case USB_SPEED_LOW:						case USB_SPEED_LOW:
				speed = "LOW"; break;						speed = "LOW"; break;
			default:							default:
				speed = "UNKNOWN"; break;					speed = "UNKNOWN"; break;
			};								};
			speed;								speed;
	} )) ;								} )) ;
	DWC_ERROR("  Max packet size: %d\n",				DWC_ERROR("  Max packet size: %d\n",
		   usb_maxpacket(urb->dev, urb->pipe, usb_pip			   usb_maxpacket(urb->dev, urb->pipe, usb_pip
	DWC_ERROR("  Data buffer length: %d\n", urb->transfer		DWC_ERROR("  Data buffer length: %d\n", urb->transfer
	DWC_ERROR("  Transfer buffer: %p, Transfer DMA: %p\n"		DWC_ERROR("  Transfer buffer: %p, Transfer DMA: %p\n"
		  urb->transfer_buffer, (void *)(u32)urb->tra			  urb->transfer_buffer, (void *)(u32)urb->tra
	DWC_ERROR("  Setup buffer: %p, Setup DMA: %p\n", urb-		DWC_ERROR("  Setup buffer: %p, Setup DMA: %p\n", urb-
		  (void *)(u32)urb->setup_dma);					  (void *)(u32)urb->setup_dma);
	DWC_ERROR("  Interval: %d\n", urb->interval);			DWC_ERROR("  Interval: %d\n", urb->interval);
	dwc_otg_hcd_complete_urb(_hcd, urb, -EIO);			dwc_otg_hcd_complete_urb(_hcd, urb, -EIO);

    /*								    /*
     * Force a channel halt. Don't call halt_channel because 	     * Force a channel halt. Don't call halt_channel because 
     * write to the HCCHARn register in DMA mode to force the	     * write to the HCCHARn register in DMA mode to force the
     */								     */
    dwc_otg_hc_halt(_hcd->core_if, _hc, DWC_OTG_HC_XFER_AHB_E	    dwc_otg_hc_halt(_hcd->core_if, _hc, DWC_OTG_HC_XFER_AHB_E
	disable_hc_int(_hc_regs, ahberr);				disable_hc_int(_hc_regs, ahberr);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel transaction error interrupt. This h	 * Handles a host channel transaction error interrupt. This h
 * called in either DMA mode or Slave mode.			 * called in either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_xacterr_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_xacterr_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "Transaction Error--\n", _hc->hc_num);			     "Transaction Error--\n", _hc->hc_num);
	switch (usb_pipetype(_qtd->urb->pipe)) {			switch (usb_pipetype(_qtd->urb->pipe)) {
	case PIPE_CONTROL:						case PIPE_CONTROL:
	case PIPE_BULK:							case PIPE_BULK:
		_qtd->error_count++;						_qtd->error_count++;
		if (!_hc->qh->ping_state) {					if (!_hc->qh->ping_state) {
			update_urb_state_xfer_intr(_hc, _hc_r				update_urb_state_xfer_intr(_hc, _hc_r
				    _qtd, DWC_OTG_HC_XFER_XAC					    _qtd, DWC_OTG_HC_XFER_XAC
			save_data_toggle(_hc, _hc_regs, _qtd)				save_data_toggle(_hc, _hc_regs, _qtd)
			if (!_hc->ep_is_in && _qtd->urb->dev-				if (!_hc->ep_is_in && _qtd->urb->dev-
				_hc->qh->ping_state = 1;					_hc->qh->ping_state = 1;
			}								}
		}								}

	    /*								    /*
	     * Halt the channel so the transfer can be re-sta		     * Halt the channel so the transfer can be re-sta
	     * the appropriate point or the PING protocol wil		     * the appropriate point or the PING protocol wil
	     */								     */
	    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_XAC		    halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER_XAC
		break;								break;
	case PIPE_INTERRUPT:						case PIPE_INTERRUPT:
		_qtd->error_count++;						_qtd->error_count++;
		if ((_hc->do_split) && (_hc->complete_split))			if ((_hc->do_split) && (_hc->complete_split))
			_qtd->complete_split = 0;					_qtd->complete_split = 0;
		}								}
		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER
		break;								break;
	case PIPE_ISOCHRONOUS:						case PIPE_ISOCHRONOUS:
		 {								 {
			dwc_otg_halt_status_e halt_status;				dwc_otg_halt_status_e halt_status;
			halt_status = update_isoc_urb_state(_				halt_status = update_isoc_urb_state(_
						  DWC_OTG_HC_							  DWC_OTG_HC_
			halt_channel(_hcd, _hc, _qtd, halt_st				halt_channel(_hcd, _hc, _qtd, halt_st
		}								}
		break;								break;
	}								}
	disable_hc_int(_hc_regs, xacterr);				disable_hc_int(_hc_regs, xacterr);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel frame overrun interrupt. This handl	 * Handles a host channel frame overrun interrupt. This handl
 * in either DMA mode or Slave mode.				 * in either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_frmovrun_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_frmovrun_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "Frame Overrun--\n", _hc->hc_num);				     "Frame Overrun--\n", _hc->hc_num);
	switch (usb_pipetype(_qtd->urb->pipe)) {			switch (usb_pipetype(_qtd->urb->pipe)) {
	case PIPE_CONTROL:						case PIPE_CONTROL:
	case PIPE_BULK:							case PIPE_BULK:
		break;								break;
	case PIPE_INTERRUPT:						case PIPE_INTERRUPT:
		halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER			halt_channel(_hcd, _hc, _qtd, DWC_OTG_HC_XFER
		break;								break;
	case PIPE_ISOCHRONOUS:						case PIPE_ISOCHRONOUS:
		 {								 {
			dwc_otg_halt_status_e halt_status;				dwc_otg_halt_status_e halt_status;
			halt_status = update_isoc_urb_state(_				halt_status = update_isoc_urb_state(_
						  DWC_OTG_HC_							  DWC_OTG_HC_
			halt_channel(_hcd, _hc, _qtd, halt_st				halt_channel(_hcd, _hc, _qtd, halt_st
		}								}
		break;								break;
	}								}
	disable_hc_int(_hc_regs, frmovrun);				disable_hc_int(_hc_regs, frmovrun);
	return 1;							return 1;
}								}

/**								/**
 * Handles a host channel data toggle error interrupt. This h	 * Handles a host channel data toggle error interrupt. This h
 * called in either DMA mode or Slave mode.			 * called in either DMA mode or Slave mode.
 */								 */
static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t * _hcd	static int32_t handle_hc_datatglerr_intr(dwc_otg_hcd_t * _hcd
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "Data Toggle Error--\n", _hc->hc_num);			     "Data Toggle Error--\n", _hc->hc_num);
	if (_hc->ep_is_in) {						if (_hc->ep_is_in) {
		_qtd->error_count = 0;						_qtd->error_count = 0;
	} else {							} else {
		DWC_ERROR("Data Toggle Error on OUT transfer,			DWC_ERROR("Data Toggle Error on OUT transfer,
			   "channel %d\n", _hc->hc_num);				   "channel %d\n", _hc->hc_num);
	}								}
	disable_hc_int(_hc_regs, datatglerr);				disable_hc_int(_hc_regs, datatglerr);
	return 1;							return 1;
}								}

#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
/**								/**
 * This function is for debug only. It checks that a valid ha	 * This function is for debug only. It checks that a valid ha
 * and that HCCHARn.chdis is clear. If there's a problem, cor	 * and that HCCHARn.chdis is clear. If there's a problem, cor
 * taken and a warning is issued.				 * taken and a warning is issued.
 * @return 1 if halt status is ok, 0 otherwise.			 * @return 1 if halt status is ok, 0 otherwise.
 */								 */
static inline int halt_status_ok(dwc_otg_hcd_t * _hcd,		static inline int halt_status_ok(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg |		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	hcchar_data_t hcchar;						hcchar_data_t hcchar;
	hctsiz_data_t hctsiz;						hctsiz_data_t hctsiz;
	hcint_data_t hcint;						hcint_data_t hcint;
	hcintmsk_data_t hcintmsk;					hcintmsk_data_t hcintmsk;
	hcsplt_data_t hcsplt;						hcsplt_data_t hcsplt;
	if (_hc->halt_status == DWC_OTG_HC_XFER_NO_HALT_STATU		if (_hc->halt_status == DWC_OTG_HC_XFER_NO_HALT_STATU
	    /*								    /*
	     * This code is here only as a check. This condit		     * This code is here only as a check. This condit
	     * never happen. Ignore the halt if it does occur		     * never happen. Ignore the halt if it does occur
	     */								     */
	    hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);		    hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);
		hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz			hctsiz.d32 = dwc_read_reg32(&_hc_regs->hctsiz
		hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);			hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
		hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcin			hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcin
		hcsplt.d32 = dwc_read_reg32(&_hc_regs->hcsplt			hcsplt.d32 = dwc_read_reg32(&_hc_regs->hcsplt
		DWC_WARN("%s: _hc->halt_status == DWC_OTG_HC_			DWC_WARN("%s: _hc->halt_status == DWC_OTG_HC_
		      "channel %d, hcchar 0x%08x, hctsiz 0x%0			      "channel %d, hcchar 0x%08x, hctsiz 0x%0
		     "hcint 0x%08x, hcintmsk 0x%08x, "				     "hcint 0x%08x, hcintmsk 0x%08x, "
		     "hcsplt 0x%08x, qtd->complete_split %d\n			     "hcsplt 0x%08x, qtd->complete_split %d\n
		     _hc->hc_num, hcchar.d32, hctsiz.d32, hci			     _hc->hc_num, hcchar.d32, hctsiz.d32, hci
		     hcintmsk.d32, hcsplt.d32, _qtd->complete			     hcintmsk.d32, hcsplt.d32, _qtd->complete
		DWC_WARN("%s: no halt status, channel %d, ign			DWC_WARN("%s: no halt status, channel %d, ign
		     __func__, _hc->hc_num);					     __func__, _hc->hc_num);
		DWC_WARN("\n");							DWC_WARN("\n");
		clear_hc_int(_hc_regs, chhltd);					clear_hc_int(_hc_regs, chhltd);
		return 0;							return 0;
	}								}

    /*								    /*
     * This code is here only as a check. hcchar.chdis should	     * This code is here only as a check. hcchar.chdis should
     * never be set when the halt interrupt occurs. Halt the	     * never be set when the halt interrupt occurs. Halt the
     * channel again if it does occur.				     * channel again if it does occur.
     */								     */
    hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);		    hcchar.d32 = dwc_read_reg32(&_hc_regs->hcchar);
	if (hcchar.b.chdis) {						if (hcchar.b.chdis) {
		DWC_WARN("%s: hcchar.chdis set unexpectedly, 			DWC_WARN("%s: hcchar.chdis set unexpectedly, 
			  "hcchar 0x%08x, trying to halt agai				  "hcchar 0x%08x, trying to halt agai
			  hcchar.d32);							  hcchar.d32);
		clear_hc_int(_hc_regs, chhltd);					clear_hc_int(_hc_regs, chhltd);
		_hc->halt_pending = 0;						_hc->halt_pending = 0;
		halt_channel(_hcd, _hc, _qtd, _hc->halt_statu			halt_channel(_hcd, _hc, _qtd, _hc->halt_statu
		return 0;							return 0;
	}								}
	return 1;							return 1;
}								}
#endif	/*  */							#endif	/*  */

/**								/**
 * Handles a host Channel Halted interrupt in DMA mode. This 	 * Handles a host Channel Halted interrupt in DMA mode. This 
 * determines the reason the channel halted and proceeds acco	 * determines the reason the channel halted and proceeds acco
 */								 */
static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t * _hcd,	static void handle_hc_chhltd_intr_dma(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	hcint_data_t hcint;						hcint_data_t hcint;
	hcintmsk_data_t hcintmsk;					hcintmsk_data_t hcintmsk;
	if (_hc->halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE |		if (_hc->halt_status == DWC_OTG_HC_XFER_URB_DEQUEUE |
		_hc->halt_status == DWC_OTG_HC_XFER_AHB_ERR) 			_hc->halt_status == DWC_OTG_HC_XFER_AHB_ERR) 
	    /*								    /*
	     * Just release the channel. A dequeue can happen		     * Just release the channel. A dequeue can happen
	     * transfer timeout. In the case of an AHB Error,		     * transfer timeout. In the case of an AHB Error,
	     * was forced to halt because there's no way to g		     * was forced to halt because there's no way to g
	     * recover.							     * recover.
	     */								     */
	    release_channel(_hcd, _hc, _qtd, _hc->halt_status		    release_channel(_hcd, _hc, _qtd, _hc->halt_status
		return;								return;
	}								}

    /* Read the HCINTn register to determine the cause for th	    /* Read the HCINTn register to determine the cause for th
    hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);		    hcint.d32 = dwc_read_reg32(&_hc_regs->hcint);
	hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcintmsk);		hcintmsk.d32 = dwc_read_reg32(&_hc_regs->hcintmsk);
	if (hcint.b.xfercomp) {						if (hcint.b.xfercomp) {

		/** @todo This is here because of a possible 			/** @todo This is here because of a possible 
		 * says that on SPLIT-ISOC OUT transfers in D			 * says that on SPLIT-ISOC OUT transfers in D
		 * interrupt w/ACK bit set should occur, but 			 * interrupt w/ACK bit set should occur, but 
		 * XFERCOMP bit, even with it masked out.  Th			 * XFERCOMP bit, even with it masked out.  Th
		 * for that behavior.  Should fix this when h			 * for that behavior.  Should fix this when h
		 */								 */
	    if ((_hc->ep_type == DWC_OTG_EP_TYPE_ISOC) && (!_		    if ((_hc->ep_type == DWC_OTG_EP_TYPE_ISOC) && (!_
			handle_hc_ack_intr(_hcd, _hc, _hc_reg				handle_hc_ack_intr(_hcd, _hc, _hc_reg
		}								}
		handle_hc_xfercomp_intr(_hcd, _hc, _hc_regs, 			handle_hc_xfercomp_intr(_hcd, _hc, _hc_regs, 
	} else if (hcint.b.stall) {					} else if (hcint.b.stall) {
		handle_hc_stall_intr(_hcd, _hc, _hc_regs, _qt			handle_hc_stall_intr(_hcd, _hc, _hc_regs, _qt
	} else if (hcint.b.xacterr) {					} else if (hcint.b.xacterr) {
	    /*								    /*
	     * Must handle xacterr before nak or ack. Could g		     * Must handle xacterr before nak or ack. Could g
	     * at the same time as either of these on a BULK/		     * at the same time as either of these on a BULK/
	     * that started with a PING. The xacterr takes pr		     * that started with a PING. The xacterr takes pr
	     */								     */
	    handle_hc_xacterr_intr(_hcd, _hc, _hc_regs, _qtd,		    handle_hc_xacterr_intr(_hcd, _hc, _hc_regs, _qtd,
	} else if (hcint.b.nyet) {					} else if (hcint.b.nyet) {
	    /*								    /*
	     * Must handle nyet before nak or ack. Could get 		     * Must handle nyet before nak or ack. Could get 
	     * same time as either of those on a BULK/CONTROL		     * same time as either of those on a BULK/CONTROL
	     * started with a PING. The nyet takes precedence		     * started with a PING. The nyet takes precedence
	     */								     */
	    handle_hc_nyet_intr(_hcd, _hc, _hc_regs, _qtd, mu		    handle_hc_nyet_intr(_hcd, _hc, _hc_regs, _qtd, mu
	} else if (hcint.b.bblerr) {					} else if (hcint.b.bblerr) {
		handle_hc_babble_intr(_hcd, _hc, _hc_regs, _q			handle_hc_babble_intr(_hcd, _hc, _hc_regs, _q
	} else if (hcint.b.frmovrun) {					} else if (hcint.b.frmovrun) {
		handle_hc_frmovrun_intr(_hcd, _hc, _hc_regs, 			handle_hc_frmovrun_intr(_hcd, _hc, _hc_regs, 
	} else if (hcint.b.datatglerr) {				} else if (hcint.b.datatglerr) {
		handle_hc_datatglerr_intr(_hcd, _hc, _hc_regs			handle_hc_datatglerr_intr(_hcd, _hc, _hc_regs
		_hc->qh->data_toggle = 0;		      <
		halt_channel(_hcd, _hc, _qtd, _hc->halt_statu <
	} else if (hcint.b.nak && !hcintmsk.b.nak) {			} else if (hcint.b.nak && !hcintmsk.b.nak) {
		/*								/*
	     * If nak is not masked, it's because a non-split		     * If nak is not masked, it's because a non-split
	     * is in an error state. In that case, the nak is		     * is in an error state. In that case, the nak is
	     * the nak interrupt handler, not here. Handle na		     * the nak interrupt handler, not here. Handle na
	     * BULK/CONTROL OUT transfers, which halt on a NA		     * BULK/CONTROL OUT transfers, which halt on a NA
	     * rewinding the buffer pointer.				     * rewinding the buffer pointer.
	     */								     */
	    handle_hc_nak_intr(_hcd, _hc, _hc_regs, _qtd, mus		    handle_hc_nak_intr(_hcd, _hc, _hc_regs, _qtd, mus
	} else if (hcint.b.ack && !hcintmsk.b.ack) {			} else if (hcint.b.ack && !hcintmsk.b.ack) {
	    /*								    /*
	     * If ack is not masked, it's because a non-split		     * If ack is not masked, it's because a non-split
	     * is in an error state. In that case, the ack is		     * is in an error state. In that case, the ack is
	     * the ack interrupt handler, not here. Handle ac		     * the ack interrupt handler, not here. Handle ac
	     * split transfers. Start splits halt on ACK.		     * split transfers. Start splits halt on ACK.
	     */								     */
	    handle_hc_ack_intr(_hcd, _hc, _hc_regs, _qtd, mus		    handle_hc_ack_intr(_hcd, _hc, _hc_regs, _qtd, mus
	} else {							} else {
		if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||			if (_hc->ep_type == DWC_OTG_EP_TYPE_INTR ||
			_hc->ep_type == DWC_OTG_EP_TYPE_ISOC)				_hc->ep_type == DWC_OTG_EP_TYPE_ISOC)
		    /*								    /*
		     * A periodic transfer halted with no oth			     * A periodic transfer halted with no oth
		     * interrupts set. Assume it was halted b			     * interrupts set. Assume it was halted b
		     * because it could not be completed in i			     * because it could not be completed in i
		     * (micro)frame.						     * (micro)frame.
		     */								     */
#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
		    DWC_PRINT("%s: Halt channel %d (assume in			    DWC_PRINT("%s: Halt channel %d (assume in
			     __func__, _hc->hc_num);					     __func__, _hc->hc_num);

#endif	/*  */							#endif	/*  */
		    halt_channel(_hcd, _hc, _qtd,				    halt_channel(_hcd, _hc, _qtd,
					 DWC_OTG_HC_XFER_PERI						 DWC_OTG_HC_XFER_PERI
		} else {							} else {
#ifdef CONFIG_DWC_DEBUG					      <
			DWC_ERROR("%s: Channel %d, DMA Mode -				DWC_ERROR("%s: Channel %d, DMA Mode -
			     "for halting is unknown, nyet %d				     "for halting is unknown, nyet %d
			     __func__, _hc->hc_num, hcint.b.n				     __func__, _hc->hc_num, hcint.b.n
				 dwc_read_reg32(&_hcd->core_i					 dwc_read_reg32(&_hcd->core_i
#endif							      <
			halt_channel(_hcd, _hc, _qtd, _hc->ha <
		}								}
	}								}
}								}

/**								/**
 * Handles a host channel Channel Halted interrupt.		 * Handles a host channel Channel Halted interrupt.
 *								 *
 * In slave mode, this handler is called only when the driver	 * In slave mode, this handler is called only when the driver
 * requests a halt. This occurs during handling other host ch	 * requests a halt. This occurs during handling other host ch
 * (e.g. nak, xacterr, stall, nyet, etc.).			 * (e.g. nak, xacterr, stall, nyet, etc.).
 *								 *
 * In DMA mode, this is the interrupt that occurs when the co	 * In DMA mode, this is the interrupt that occurs when the co
 * processing a transfer on a channel. Other host channel int	 * processing a transfer on a channel. Other host channel int
 * ahberr) are disabled in DMA mode.				 * ahberr) are disabled in DMA mode.
 */								 */
static int32_t handle_hc_chhltd_intr(dwc_otg_hcd_t * _hcd,	static int32_t handle_hc_chhltd_intr(dwc_otg_hcd_t * _hcd,
	dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg		dwc_hc_t * _hc, dwc_otg_hc_regs_t * _hc_regs, dwc_otg
{								{
	DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "		DWC_DEBUGPL(DBG_HCD, "--Host Channel %d Interrupt: "
		     "Channel Halted--\n", _hc->hc_num);			     "Channel Halted--\n", _hc->hc_num);
	if (_hcd->core_if->dma_enable) {				if (_hcd->core_if->dma_enable) {
		handle_hc_chhltd_intr_dma(_hcd, _hc, _hc_regs			handle_hc_chhltd_intr_dma(_hcd, _hc, _hc_regs
	} else {							} else {
#ifdef CONFIG_DWC_DEBUG						#ifdef CONFIG_DWC_DEBUG
	    if (!halt_status_ok(_hcd, _hc, _hc_regs, _qtd, mu |		    if (!halt_status_ok(_hcd, _hc, _hc_regs, _qtd)) {
			return 1;							return 1;
		}								}
#endif	/*  */							#endif	/*  */
	    release_channel(_hcd, _hc, _qtd, _hc->halt_status		    release_channel(_hcd, _hc, _qtd, _hc->halt_status
	}								}
							      >		clear_hc_int(_hc_regs, chhltd);
	return 1;							return 1;
}								}

/** Handles interrupt for a specific Host Channel */		/** Handles interrupt for a specific Host Channel */
int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t * _dwc_otg	int32_t dwc_otg_hcd_handle_hc_n_intr(dwc_otg_hcd_t * _dwc_otg
{								{
	int must_free = 0;						int must_free = 0;
	int retval = 0;							int retval = 0;
	hcint_data_t hcint;						hcint_data_t hcint;
	hcintmsk_data_t hcintmsk;					hcintmsk_data_t hcintmsk;
	dwc_hc_t * hc;							dwc_hc_t * hc;
	dwc_otg_hc_regs_t * hc_regs;					dwc_otg_hc_regs_t * hc_regs;
	dwc_otg_qtd_t * qtd;						dwc_otg_qtd_t * qtd;
	DWC_DEBUGPL(DBG_HCDV, "--Host Channel Interrupt--, Ch		DWC_DEBUGPL(DBG_HCDV, "--Host Channel Interrupt--, Ch
	hc = _dwc_otg_hcd->hc_ptr_array[_num];				hc = _dwc_otg_hcd->hc_ptr_array[_num];
	hc_regs = _dwc_otg_hcd->core_if->host_if->hc_regs[_nu		hc_regs = _dwc_otg_hcd->core_if->host_if->hc_regs[_nu
	qtd = list_entry(hc->qh->qtd_list.next, dwc_otg_qtd_t		qtd = list_entry(hc->qh->qtd_list.next, dwc_otg_qtd_t
	hcint.d32 = dwc_read_reg32(&hc_regs->hcint);			hcint.d32 = dwc_read_reg32(&hc_regs->hcint);
	hcintmsk.d32 = dwc_read_reg32(&hc_regs->hcintmsk);		hcintmsk.d32 = dwc_read_reg32(&hc_regs->hcintmsk);
	DWC_DEBUGPL(DBG_HCDV, " hcint 0x%08x, hcintmsk 0x%08x		DWC_DEBUGPL(DBG_HCDV, " hcint 0x%08x, hcintmsk 0x%08x
		     hcint.d32, hcintmsk.d32, (hcint.d32 & hc			     hcint.d32, hcintmsk.d32, (hcint.d32 & hc
	hcint.d32 = hcint.d32 & hcintmsk.d32;				hcint.d32 = hcint.d32 & hcintmsk.d32;
	if (!_dwc_otg_hcd->core_if->dma_enable) {			if (!_dwc_otg_hcd->core_if->dma_enable) {
		if ((hcint.b.chhltd) && (hcint.d32 != 0x2)) {			if ((hcint.b.chhltd) && (hcint.d32 != 0x2)) {
			hcint.b.chhltd = 0;						hcint.b.chhltd = 0;
		}								}
	}								}
	if (hcint.b.xfercomp) {						if (hcint.b.xfercomp) {
		retval |= handle_hc_xfercomp_intr(_dwc_otg_hc			retval |= handle_hc_xfercomp_intr(_dwc_otg_hc
	    /*								    /*
	     * If NYET occurred at same time as Xfer Complete		     * If NYET occurred at same time as Xfer Complete
	     * handled by the Xfer Complete interrupt handler		     * handled by the Xfer Complete interrupt handler
	     * to call the NYET interrupt handler in this cas		     * to call the NYET interrupt handler in this cas
	     */								     */
	    hcint.b.nyet = 0;						    hcint.b.nyet = 0;
	}								}
	if (hcint.b.chhltd) {						if (hcint.b.chhltd) {
		retval |= handle_hc_chhltd_intr(_dwc_otg_hcd,			retval |= handle_hc_chhltd_intr(_dwc_otg_hcd,
	}								}
	if (hcint.b.ahberr) {						if (hcint.b.ahberr) {
		retval |= handle_hc_ahberr_intr(_dwc_otg_hcd,			retval |= handle_hc_ahberr_intr(_dwc_otg_hcd,
	}								}
	if (hcint.b.stall) {						if (hcint.b.stall) {
		retval |= handle_hc_stall_intr(_dwc_otg_hcd, 			retval |= handle_hc_stall_intr(_dwc_otg_hcd, 
	}								}
	if (hcint.b.nak) {						if (hcint.b.nak) {
		retval |= handle_hc_nak_intr(_dwc_otg_hcd, hc			retval |= handle_hc_nak_intr(_dwc_otg_hcd, hc
	}								}
	if (hcint.b.ack) {						if (hcint.b.ack) {
		retval |= handle_hc_ack_intr(_dwc_otg_hcd, hc			retval |= handle_hc_ack_intr(_dwc_otg_hcd, hc
	}								}
	if (hcint.b.nyet) {						if (hcint.b.nyet) {
		retval |= handle_hc_nyet_intr(_dwc_otg_hcd, h			retval |= handle_hc_nyet_intr(_dwc_otg_hcd, h
	}								}
	if (hcint.b.xacterr) {						if (hcint.b.xacterr) {
		retval |= handle_hc_xacterr_intr(_dwc_otg_hcd			retval |= handle_hc_xacterr_intr(_dwc_otg_hcd
	}								}
	if (hcint.b.bblerr) {						if (hcint.b.bblerr) {
		retval |= handle_hc_babble_intr(_dwc_otg_hcd,			retval |= handle_hc_babble_intr(_dwc_otg_hcd,
	}								}
	if (hcint.b.frmovrun) {						if (hcint.b.frmovrun) {
		retval |= handle_hc_frmovrun_intr(_dwc_otg_hc			retval |= handle_hc_frmovrun_intr(_dwc_otg_hc
	}								}
	if (hcint.b.datatglerr) {					if (hcint.b.datatglerr) {
		retval |= handle_hc_datatglerr_intr(_dwc_otg_			retval |= handle_hc_datatglerr_intr(_dwc_otg_
	}								}
	/*								/*
	 * Logic to free the qtd here, at the end of the hc i		 * Logic to free the qtd here, at the end of the hc i
	 * processing, if the handling of this interrupt dete		 * processing, if the handling of this interrupt dete
	 * that it needs to be freed.					 * that it needs to be freed.
	 */								 */
	if (must_free) {						if (must_free) {
		/* Free the qtd here now that we are done usi			/* Free the qtd here now that we are done usi
		dwc_otg_hcd_qtd_free(qtd);					dwc_otg_hcd_qtd_free(qtd);
	}								}
	return retval;							return retval;
}								}

#endif	/* DWC_DEVICE_ONLY */					#endif	/* DWC_DEVICE_ONLY */
